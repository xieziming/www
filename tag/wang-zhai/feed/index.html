<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>网摘 &#8211; 谢子明</title>
	<atom:link href="http://www.xieziming.com/tag/wang-zhai/feed" rel="self" type="application/rss+xml" />
	<link>http://www.xieziming.com</link>
	<description>Suny Xie</description>
	<lastBuildDate>Mon, 26 Dec 2016 07:34:38 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.7</generator>
	<item>
		<title>12星座最配与最不配</title>
		<link>http://www.xieziming.com/archives/5958.html</link>
		<comments>http://www.xieziming.com/archives/5958.html#respond</comments>
		<pubDate>Mon, 20 Jun 2011 02:28:41 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[网摘]]></category>
		<category><![CDATA[星座]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=5958</guid>
		<description><![CDATA[<font color="#8B4513"><strong>白羊座</strong></font>

绝配：白羊座人有刚强的倔强的天性，所以适合找能肯定他的人。会巧妙地安排生活的狮子座是最合适的对象；个性明朗乐观的射手座会以最宽厚的态度谦让你，个性相投。有共同目的又能互相勉励的白羊座也是相称的对象。

绝不能配：性情易变的巨蟹座，优柔寡断的天秤座，古板的，固执的魔羯座，都不宜相配。

<font color="#8B4513"><strong>金牛座</strong></font>

绝配：金牛座人重视安全与舒适。最佳的对象就是对家族和家庭有责任感的人。坚韧不拔的魔羯座；有正确周密的生活设计并努力于建设和平家庭的处女座；和你兴趣及嗜好相投同属金牛座的，都是适合的对象。

绝不能配：爱慕虚荣的狮子座；深沉而顽固的天蝎座，叛逆怪异的水瓶座。

<font color="#8B4513"><strong>双子座</strong></font>

绝配：双子座不喜欢单调的生活，所以水瓶座能带来新鲜的变化，这是最理想的对象，带给你年轻及活力。聪明活泼，温柔可爱的天秤座及知识水平相当高的双子座，也适合你。

绝不能配：处女座会变成累赘而无法相处的对象；射手座是使你成为神经过敏的主因；双鱼座空洞乏味的人生，会使你无法与他沟通。]]></description>
				<content:encoded><![CDATA[<p><font color="#8B4513"><strong>白羊座</strong></font></p>
<p>绝配：白羊座人有刚强的倔强的天性，所以适合找能肯定他的人。会巧妙地安排生活的狮子座是最合适的对象；个性明朗乐观的射手座会以最宽厚的态度谦让你，个性相投。有共同目的又能互相勉励的白羊座也是相称的对象。</p>
<p>绝不能配：性情易变的巨蟹座，优柔寡断的天秤座，古板的，固执的魔羯座，都不宜相配。</p>
<p><font color="#8B4513"><strong>金牛座</strong></font></p>
<p>绝配：金牛座人重视安全与舒适。最佳的对象就是对家族和家庭有责任感的人。坚韧不拔的魔羯座；有正确周密的生活设计并努力于建设和平家庭的处女座；和你兴趣及嗜好相投同属金牛座的，都是适合的对象。</p>
<p>绝不能配：爱慕虚荣的狮子座；深沉而顽固的天蝎座，叛逆怪异的水瓶座。</p>
<p><font color="#8B4513"><strong>双子座</strong></font></p>
<p>绝配：双子座不喜欢单调的生活，所以水瓶座能带来新鲜的变化，这是最理想的对象，带给你年轻及活力。聪明活泼，温柔可爱的天秤座及知识水平相当高的双子座，也适合你。</p>
<p>绝不能配：处女座会变成累赘而无法相处的对象；射手座是使你成为神经过敏的主因；双鱼座空洞乏味的人生，会使你无法与他沟通。</p>
<p><font color="#8B4513"><strong>巨蟹座</strong></font></p>
<p>绝配：巨蟹座是多情人，喜欢&#8217;爱情长跑&#8217;，一旦恋爱则会奉献到底。充满罗曼蒂克且重视内在及爱情的双鱼座；同样能献出生命的天蝎座；还有同是巨蟹座的对象，都是最理想的搭配。</p>
<p>绝不能配：生活方式完全不同的天秤座；整天愁眉苦脸又爱教训他人的魔羯座；冲动莽撞的白羊座。</p>
<p><font color="#8B4513"><strong>狮子座</strong></font></p>
<p>绝配：狮子座好表现，喜欢被人恭维，理想的对象是可以和你分忧、同甘共苦的白羊座；有自由、进步思想、开朗、愿和你享受人生、实现理想的射手座；还有同属狮子座的人，均为相称的对象。</p>
<p>绝不能配：过于自私、坚持而阴沉的天蝎座；能打破你一切理想的水瓶座；顽固的金牛座，都不会幸福的。</p>
<p><font color="#8B4513"><strong>处女座</strong></font></p>
<p>绝配：处女座憧憬纯情，相称的对象是能使他尊敬又具童心的金牛座；稳重踏实又有经济基础的魔羯座；重精神生活的处女座。</p>
<p>绝不能配：会使你感到没有责任感或轻浮的射手座；双鱼座也会使你郁闷。</p>
<p><font color="#8B4513"><strong>天秤座</strong></font></p>
<p>绝配：天秤座相称的对象，如追求安全和快乐生活及遇到困难决不退缩的水瓶座；天真活泼爱美且富幽默，使你不会感到孤独的双子座；同样具有中庸平和性格的天秤座，均比较理想。</p>
<p>绝不能配：保守朴素的没有生气的魔羯座；粗野而性急的白羊座，离婚的多；生活步调不和谐的巨蟹座会使生活步调紊乱。</p>
<p><font color="#8B4513"><strong>天蝎座</strong></font></p>
<p>绝配：天蝎座相称对象是爱情、钱财及精神上都能相互尊重对方秘密的双鱼座；能负起建设及保卫家园的巨蟹座；同样属于天蝎座的对象，能互相保持诚信，过着和平而快乐的生活。</p>
<p>绝不能配：饶舌多嘴的水瓶座是不合适的；固执而贪欲重的金牛座会起冲突；虚荣或故弄玄虚的狮子座只会令你失望。</p>
<p><font color="#8B4513"><strong>射手座</strong></font></p>
<p>绝配：无拘无束、天马行空，拒绝被操控的射手，和白羊是天造地设的一对，和金牛也能互相欣赏。跳跃的双子则具有致命的吸引力，射手和巨蟹也会有神秘的缘分哦。</p>
<p>绝不能配：和处女座互相看不顺眼，对刻板的魔羯座比较没有感觉，浪漫的双鱼和射手也是不太会有相交和结果的。</p>
<p><font color="#8B4513"><strong>魔羯座</strong></font></p>
<p>绝配：魔羯座孤独、忍耐的性格，加上半生的努力，比一般人晚发；所以必须寻找一位能相互合作又和蔼可亲的对象。如温和体贴富有同情心的处女座；永远年轻的金牛座；以及有耐心、殷实可靠同属魔羯座的人，都很相称。</p>
<p>绝不能配：纯真率直而带顽固暴力的白羊座；多才多艺但情绪化的巨蟹座会导致分裂；生活方针不同的天秤座易起争执而分离。</p>
<p><font color="#8B4513"><strong>水瓶座</strong></font></p>
<p>绝配：具有通融性又能尊重他人的双子座最为合适；和你保持和谐及关怀的天秤座；具有深邃洞察力又富人道精神的水瓶座，是最适合的。</p>
<p>绝不能配：不知变通的金牛座；爱情观距离过大使生活步调紊乱的狮子座；阴沉坚持的天蝎座，会使双方陷入冷战。</p>
<p><font color="#8B4513"><strong>双鱼座</strong></font></p>
<p>绝配：心灵手巧又爱家的巨蟹座；对爱情及私生活相当重视的天蝎座；具有牺牲奉献精神、同甘共苦同属双鱼座的，都是适合的对象。</p>
<p>绝不能配：爱情观不相合的双子座使你感到无法信赖；挑剔琐碎的处女座会谱出离婚曲；射手座对双鱼座的分裂性格过于了解，会使你过着没有欢乐的生活。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/5958.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>漫谈工业过程控制系统</title>
		<link>http://www.xieziming.com/archives/7140.html</link>
		<comments>http://www.xieziming.com/archives/7140.html#respond</comments>
		<pubDate>Fri, 13 May 2011 15:10:04 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[网摘]]></category>
		<category><![CDATA[Automation]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7140</guid>
		<description><![CDATA[常见的工业控制系统有分布式控制系统（Distributed Control System，简称DCS）、可编程序逻辑控制器（Programmable Logic Controller，简称PLC）、容错控制器（Fail Safe Controller，简称FSC）、多功能控制器（Multifunctional Controller，简称MFC）等。FSC就是特别可靠的PLC，使用起来也特别麻烦；MFC是专用于强电系统（输变电、大功率电机、变频电机等）的PLC；所以粗粗归类，也就是PLC和DCS两大类。
 

在谈PLC和DCS之前，应该指出，还有一类系统通常不作为工业过程控制问题考虑，那就是像导弹控制、汽车发动机控制、洗衣机控制、电热咖啡壶控制等，这些控制问题一般使用专用的控制系统，和被控制对象紧密结合，通常称为嵌入式系统（embeded control system），不在这篇小文的范围内。
 

控制问题分两大类：连续控制和断续控制（也叫开关控制）。汽车的方向盘就是连续控制的一个例子，司机连续地恰到好处地转动方向盘以控制方向；电饭煲的温度控制就是断续控制的一个例子，只有开和关两个位置，按下开关后，温度上升到一定的时候，自动断电；温度下来了，又自动加电保温。稍微复杂一点的断续控制可以是多位控制，除了全开、全关两个位置外，中间还可以有一个甚至多个渐进的半开位置。一般来说，DCS适合连续过程控制，像化工、发电、冶金、造纸的工艺过程，PLC适合断续过程控制，像各种机电设备。这是由不同的历史背景导致的。在还没有计算机的远古时代，连续控制的PID是用气动或者电动调节器（行话叫单元仪表）实现的，连锁保护则是用继电器实现的。前者控制阀门或者变频电机连续变化，达到精确控制。后者则是自动化的开关控制，用于在某一事件触发下，自动执行一系列动作。复杂一点的继电器控制还有延时，可以执行一系列步骤，每一步可以包含一定的延时，传统上用凸轮实现。复杂继电器控制还可以包含滞环（也叫死区）等比较“反动”的功能。在很长的时间里，单元仪表和继电器之间是井水不犯河水，老死不相往来，直到数字式计算机的出现。]]></description>
				<content:encoded><![CDATA[<p>常见的工业控制系统有分布式控制系统（Distributed Control System，简称DCS）、可编程序逻辑控制器（Programmable Logic Controller，简称PLC）、容错控制器（Fail Safe Controller，简称FSC）、多功能控制器（Multifunctional Controller，简称MFC）等。FSC就是特别可靠的PLC，使用起来也特别麻烦；MFC是专用于强电系统（输变电、大功率电机、变频电机等）的PLC；所以粗粗归类，也就是PLC和DCS两大类。</p>
<p>在谈PLC和DCS之前，应该指出，还有一类系统通常不作为工业过程控制问题考虑，那就是像导弹控制、汽车发动机控制、洗衣机控制、电热咖啡壶控制等，这些控制问题一般使用专用的控制系统，和被控制对象紧密结合，通常称为嵌入式系统（embeded control system），不在这篇小文的范围内。</p>
<p>控制问题分两大类：连续控制和断续控制（也叫开关控制）。汽车的方向盘就是连续控制的一个例子，司机连续地恰到好处地转动方向盘以控制方向；电饭煲的温度控制就是断续控制的一个例子，只有开和关两个位置，按下开关后，温度上升到一定的时候，自动断电；温度下来了，又自动加电保温。稍微复杂一点的断续控制可以是多位控制，除了全开、全关两个位置外，中间还可以有一个甚至多个渐进的半开位置。一般来说，DCS适合连续过程控制，像化工、发电、冶金、造纸的工艺过程，PLC适合断续过程控制，像各种机电设备。这是由不同的历史背景导致的。在还没有计算机的远古时代，连续控制的PID是用气动或者电动调节器（行话叫单元仪表）实现的，连锁保护则是用继电器实现的。前者控制阀门或者变频电机连续变化，达到精确控制。后者则是自动化的开关控制，用于在某一事件触发下，自动执行一系列动作。复杂一点的继电器控制还有延时，可以执行一系列步骤，每一步可以包含一定的延时，传统上用凸轮实现。复杂继电器控制还可以包含滞环（也叫死区）等比较“反动”的功能。在很长的时间里，单元仪表和继电器之间是井水不犯河水，老死不相往来，直到数字式计算机的出现。</p>
<p>冯·诺依曼同学发明二进制计算机的概念，成功地打破了连续变量和离散变量的界限，这是计算机控制可以实现连续的PID控制和离散的继电器控制的基础。PID在本质上是一个数学计算，计算机的计算能力强大，做PID当然不在话下。事实上，即使不太先进的计算机也可以以一当百，一台计算机巡回扫描，把百十个PID回路吃下来不成问题。计算机还可以实现更先进的数学控制方法，如最优控制、自适应控制、模型预估控制等，用软件“连接”串级、前馈、分程、比例、超驰控制回路也比单元仪表时代拖电线容易得太多，很快就在工业界得到极大的欢迎。计算机控制用显示屏代替动辄几十米长的仪表板，也使超大型的控制系统得以实用化。早年的计算机控制系统大多采用大型计算机，如IBM的AIX系统，最不济也是DEC的PDP11，或者后来的VAX。但是集中的大型计算机是计算机控制系统可靠性的薄弱环节，一旦这台大型计算机出故障，整个系统就当掉了。 </p>
<p>为了提高计算机控制系统的可靠性，人们做了很多努力。冗余计算机是最早的解决方案，但微机的出现，在根本上解决了计算机控制系统的可靠性问题。微机的成本低，体积小，于是分散到很多基本控制单元但又通过网络连接的所谓集散控制系统就应运而生了，这就是今天的DCS。DCS的基本单元具有基本的I/O和控制功能，即使和网络断开，也能保证基本的控制功能。但和网络相连，就可以实现更强大的控制和管理功能。这就使所谓“集散”的缘由。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7140.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>自动控制理论（一）</title>
		<link>http://www.xieziming.com/archives/7125.html</link>
		<comments>http://www.xieziming.com/archives/7125.html#respond</comments>
		<pubDate>Fri, 13 May 2011 14:37:50 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[网摘]]></category>
		<category><![CDATA[Automation]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7125</guid>
		<description><![CDATA[小时候喜欢看杂书，没什么东西看，不正在文化大革命嘛？不过看进去了两个“化”：机械化和自动化。打小就没有弄明白，这机械化和自动化到底有什么差别，机器不是自己就会动的吗？长大了，总算稍微明白了一点，这机械化是力气活，用机器代替人的体力劳动，但还是要人管着的，不然机器是不知道该干什么不该干什么的；这自动化嘛，就是代替人的重复脑力劳动，是用来管机器的。也就是说，自动化是管着机械化的，或者说学自动化的是管着学机械的……啊，不对，不对，哪是哪啊！


有人考证古代就有自动化的实例，但现代意义上的自动控制开始于瓦特的蒸汽机。据说纽考门比瓦特先发明蒸汽机，但是蒸汽机的转速控制问题没有解决，弄不好转速飞升，机器损坏不说，还可能说大事故。瓦特在蒸汽机的转轴上安了一个小棍，棍的一端和放汽阀连着，棍的另一端是一个小重锤，棍中间某个地方通过支点和转轴连接。转轴转起来的时候，重锤由于离心力的缘故挥起来。转速太高了，重锤挥得很高，放汽阀就被按下去，转速下降；转速太低了，重锤不起来，放汽阀就被松开，转速回升。这样，蒸汽机可以自动保持稳定的转速，即保证安全，又方便使用。也就是因为这个小小的转速调节器，瓦特的名字和工业革命连在一起，而纽考门的名字就要到历史书里去找了。

 

类似的例子在机械系统里很多，家居必备的抽水马桶是另一个例子。放水冲刷后，水箱里水位降低，浮子随水面下降，进水阀打开。随着水位的升高，进水阀逐渐关闭，直到水位达到规定高度，进水阀完全关闭，水箱的水正好准备下一次使用。这是一个非常简单但非常巧妙的水位控制系统，是一个经典的设计，但不容易用经典的控制理论来分析，不过这是题外话了。

 

这些机械系统设计巧妙，工作可靠，实在是巧夺天工。但是在实用中，如果每次都需要这样的创造性思维，那太累，最好有一个系统的方法，可以解决“所有”的自动控制问题，这就是控制理论的由来。]]></description>
				<content:encoded><![CDATA[<p><strong>引子</strong></p>
<p>小时候喜欢看杂书，没什么东西看，不正在文化大革命嘛？不过看进去了两个“化”：机械化和自动化。打小就没有弄明白，这机械化和自动化到底有什么差别，机器不是自己就会动的吗？长大了，总算稍微明白了一点，这机械化是力气活，用机器代替人的体力劳动，但还是要人管着的，不然机器是不知道该干什么不该干什么的；这自动化嘛，就是代替人的重复脑力劳动，是用来管机器的。也就是说，自动化是管着机械化的，或者说学自动化的是管着学机械的……啊，不对，不对，哪是哪啊！</p>
<p>有人考证古代就有自动化的实例，但现代意义上的自动控制开始于瓦特的蒸汽机。据说纽考门比瓦特先发明蒸汽机，但是蒸汽机的转速控制问题没有解决，弄不好转速飞升，机器损坏不说，还可能说大事故。瓦特在蒸汽机的转轴上安了一个小棍，棍的一端和放汽阀连着，棍的另一端是一个小重锤，棍中间某个地方通过支点和转轴连接。转轴转起来的时候，重锤由于离心力的缘故挥起来。转速太高了，重锤挥得很高，放汽阀就被按下去，转速下降；转速太低了，重锤不起来，放汽阀就被松开，转速回升。这样，蒸汽机可以自动保持稳定的转速，即保证安全，又方便使用。也就是因为这个小小的转速调节器，瓦特的名字和工业革命连在一起，而纽考门的名字就要到历史书里去找了。</p>
<p>类似的例子在机械系统里很多，家居必备的抽水马桶是另一个例子。放水冲刷后，水箱里水位降低，浮子随水面下降，进水阀打开。随着水位的升高，进水阀逐渐关闭，直到水位达到规定高度，进水阀完全关闭，水箱的水正好准备下一次使用。这是一个非常简单但非常巧妙的水位控制系统，是一个经典的设计，但不容易用经典的控制理论来分析，不过这是题外话了。</p>
<p>这些机械系统设计巧妙，工作可靠，实在是巧夺天工。但是在实用中，如果每次都需要这样的创造性思维，那太累，最好有一个系统的方法，可以解决“所有”的自动控制问题，这就是控制理论的由来。</p>
<p><strong>反馈和动态</strong></p>
<p>从小大人就教我们，走路要看路。为什么呢？要是不看着路，走路走歪了也不知道，结果就是东撞西撞的。要是看着路呢？走歪了，马上就看到，赶紧调整脚步，走回到正道上来。这里有自动控制里的第一个重要概念：反馈（feedback）。</p>
<p>反馈是一个过程：</p>
<p>1、设定目标，对小朋友走路的例子来说，就是前进的路线。</p>
<p>2、测量状态，小朋友的眼睛看着路，就是在测量自己的前进方向。</p>
<p>3、将测量到的状态和设定的目标比较，把眼睛看到的前进方向和心里想的前进方向作比较，判断前进方向是否正确；如果不正确，相差有多少。</p>
<p>4、调整行动，在心里根据实际前进方向和设定目标的偏差，决定调整的量。</p>
<p>5、实际执行，也就是实际挪动脚步，重回正确的前进方向。</p>
<p>在整个走路的过程中，这个反馈过程周而复始，不断进行，这样，小朋友就不会走得东倒西歪了。但是，这里有一个问题：如果所有的事情都是在瞬时里同时发生的，那这个反馈过程就无法工作。要使反馈工作，一定要有一定的反应时间。还好，世上之事，都有一个过程，这就为反馈赢得了所需要的时间。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7125.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>自动控制理论（二）</title>
		<link>http://www.xieziming.com/archives/7133.html</link>
		<comments>http://www.xieziming.com/archives/7133.html#respond</comments>
		<pubDate>Fri, 13 May 2011 12:59:11 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[网摘]]></category>
		<category><![CDATA[Automation]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7133</guid>
		<description><![CDATA[形形色色的控制理论再牛，没有被控过程的数学模型，照样抓瞎。前面的洗澡水温就是一个数学模型。这个模型是杜撰的，当然可以很容易地给它所有模型参数。但在实际中，模型参数不会从天上掉下来。多少科学家毕生致力于建立某一特定的物理、生物、化学或别的学科的数学模型，基本机制已经清楚的模型都不容易建立，更不用说很多过程的基本机制或深层机制并不清楚。所以靠机理推导被控过程的数学模型是可能的，但对日常的控制问题来说，并不实际。这就是控制理论的另一个分支—辨识—一显身手的地方了。

 

如果给定一个模型，也就是一个数学公式，给它一组输入数据，模型就可以计算出对应的输出数据。比如说，给定模型y=2*x+1，再给出x=1，2，3，4，那y就等于3，5，7，9，就这么很简单。辨识的问题反过来，先给定一个模型结构，在这里就是y=a*x+b，已知输入-输出数据是x=1，2时y=3，5，要求计算出a和b。显然，这是一个二元一次方程，谁都会解。在实际中，输入-输出的观察数据含有测量噪声，这对参数估计的精度不利；但通常积累观察的数据量远远超过未知参数的个数，不说数学，感觉上这就应该对克服测量噪声有利，关键是怎么利用这“多余”的数据。一个办法是把数据组两两配对，借众多的二元一次方程，然后对解出来的a和b作平均。还有一个办法就是有名的最小二乘法了，说穿了，就是以a和b为最优化的“控制量”，使模型输出和实际观测值之间的累积平方误差为最小。

 

实际工业过程大多有多年的运行经验，大量的数据不成问题。对于大多数常见过程，模型的基本结构和定性性质也可以猜一个八九不离十，有了如此有力的数学“大锤”，那么应该可以砸开一切建模的硬核桃啦。且慢，世上没有真正的“神奇子弹”，一个问题解决了，另一个同等难度的问题又会出现。对于辨识来说，问题有好几个。]]></description>
				<content:encoded><![CDATA[<p><strong>辨识</strong></p>
<p>形形色色的控制理论再牛，没有被控过程的数学模型，照样抓瞎。前面的洗澡水温就是一个数学模型。这个模型是杜撰的，当然可以很容易地给它所有模型参数。但在实际中，模型参数不会从天上掉下来。多少科学家毕生致力于建立某一特定的物理、生物、化学或别的学科的数学模型，基本机制已经清楚的模型都不容易建立，更不用说很多过程的基本机制或深层机制并不清楚。所以靠机理推导被控过程的数学模型是可能的，但对日常的控制问题来说，并不实际。这就是控制理论的另一个分支—辨识—一显身手的地方了。</p>
<p>如果给定一个模型，也就是一个数学公式，给它一组输入数据，模型就可以计算出对应的输出数据。比如说，给定模型y=2*x+1，再给出x=1，2，3，4，那y就等于3，5，7，9，就这么很简单。辨识的问题反过来，先给定一个模型结构，在这里就是y=a*x+b，已知输入-输出数据是x=1，2时y=3，5，要求计算出a和b。显然，这是一个二元一次方程，谁都会解。在实际中，输入-输出的观察数据含有测量噪声，这对参数估计的精度不利；但通常积累观察的数据量远远超过未知参数的个数，不说数学，感觉上这就应该对克服测量噪声有利，关键是怎么利用这“多余”的数据。一个办法是把数据组两两配对，借众多的二元一次方程，然后对解出来的a和b作平均。还有一个办法就是有名的最小二乘法了，说穿了，就是以a和b为最优化的“控制量”，使模型输出和实际观测值之间的累积平方误差为最小。</p>
<p>实际工业过程大多有多年的运行经验，大量的数据不成问题。对于大多数常见过程，模型的基本结构和定性性质也可以猜一个八九不离十，有了如此有力的数学“大锤”，那么应该可以砸开一切建模的硬核桃啦。且慢，世上没有真正的“神奇子弹”，一个问题解决了，另一个同等难度的问题又会出现。对于辨识来说，问题有好几个。</p>
<p>第一个问题是工业数据的闭环性。大多数重要参数都有闭环回路控制。如果没有闭环回路控制，那要么就是过程特性实在太复杂，简单回路控制不了；要么就是这个参数其实不重要，飘移一点没人在乎。然而，一旦闭环，系统地输入和输出就是相关的了。这一相关不要紧，输入-输出数据之间的因果性就全乱了：输出通过被控过程本身和输入相关（这是好的，辨识就是要测算出这个相关关系，输出要是和输入不相关，也没有控制或辨识什么事了），输入通过反馈和输出相关；输入-输出成为一个闭合系统，你可以用任意多条定理或方法证明同样的事：由于因果不分，闭环辨识是不可能的，除非另外加入“新鲜”的激励，比如使劲变设定值，或者在闭环回路里额外施加独立于输入、输出的激励信号，比如“莫名其妙”地把阀门动几下。弄到最后，工业数据到底能用多少，就不是一个简单的回答。有的过程常年稳定操作，像乙烯装置，只有小范围的微调。这倒不是人家懒或者不求上进，而是这些装置早已高度优化，常年操作在极其接近极限的位置，但原料和产品单一，所以工艺状况不怎么大变。这种系统的闭环数据用起来很吃力，常常必须做一定的开环试验。有的过程经常在不同的状态之间转换（transition），或者由于不同的原料，如“吃”得很杂的炼油厂，或者由于不同的产品，如聚乙烯装置，这实际上就是“使劲变设定值”，是新鲜的激励。这种系统的闭环数据比较好用，但有别的问题，下面要谈到。</p>
<p>第二个问题是动态和稳态。动态模型的作用有两个：一是描述需要多少时间输出才能达到某一数值；二是输出最终能够达到什么数值。用股票市场举一个例子，你需要知道两件事：一是这支股票最后会升到多少，二是需要多少时间才能升到那里，只知道其中一个对你并没有太大的用处。当然为了简化，这里假定这支股票一路飙升，不来忽升忽降（也就是非线性）或跌买涨卖（也就是闭环影响）的名堂。这就要求输入-输出数据必须包含充分的动态和稳态信息，过于偏颇其中一方面对另一方面会不利。所以，长期稳定运行的过程中可能包含足够的稳态数据，但动态不足；常年不怎么稳定的过程可能包含足够的动态数据，但稳态不足。用PID控制打比方，精确的稳态数据有助于计算正确的比例控制增益，精确的动态数据有助于计算正确的积分和微分增益，显然，把比例增益整对了更为重要。为了获得精确的稳态，在辨识中常常需要等过程开环稳定下来才进行下一步，但是问题是，实际过程有时时间常数很长，几个精馏塔一串联，时间常数几个小时是客气的，一、两天都是可能的。这样一来，一个不太大的模型，十来个变量，开环试验一做就是一、两个星期或者更长。要是一个装置能够两个星期开环，那也不需要什么控制了。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7133.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>链接器和装入器</title>
		<link>http://www.xieziming.com/archives/7170.html</link>
		<comments>http://www.xieziming.com/archives/7170.html#respond</comments>
		<pubDate>Tue, 25 May 2010 14:39:49 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[技术维基]]></category>
		<category><![CDATA[程序]]></category>
		<category><![CDATA[网摘]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7170</guid>
		<description><![CDATA[<strong>1．静态链接、静态装入</strong>

这种方法最早被采用，其特点是简单，不需要操作系统提供任何额外的支持。像C这样的编程语言从很早开始就已经支持分别编译了，程序的不同模块可以并行开发，然后独立编译为相应的目标文件。在得到了所有的目标文件后，静态链接、静态装入的做法是将所有目标文件链接成一个可执行映象，随后在创建进程时将该可执行映象一次全部装入内存。

举个简单的例子，假设我们开发了两个程序Prog1和Prog2，Prog1由main1.c、utilities.c以及errhdl1.c三部分组成，分别对应程序的主框架、一些公用的辅助函数（其作用相当于库）以及错误处理部分，这三部分代码编译后分别得到各自对应的目标文件main1.o、utilities.o以及errhdl1.o。同样，Prog2由main2.c、utilities.c以及errhdl2.c三部分组成，三部分代码编译后分别得到各自对应的目标文件main2.o、utilities.o以及errhdl2.o。值得注意的是，这里Prog1和Prog2使用了相同的公用辅助函数utilities.o。当我们采用静态链接、静态装入的方法，可以看到，首先就硬盘的使用来讲，虽然两个程序共享使用了utilities，但这并没有在硬盘保存的可执行程序映象上体现出来。相反，utilities.o被链接进了每一个用到它的程序的可执行映象。内存的使用也是如此，操作系统在创建进程时将程序的可执行映象一次全部装入内存，之后进程才能开始运行。如前所述，采用这种方法使得操作系统的实现变得非常简单，但其缺点也是显而易见的。首先，既然两个程序使用的是相同的utilities.o，那么我们只要在硬盘上保存utilities.o的一份拷贝应该就足够了；另外，假如程序在运行过程中没有出现任何错误，那么错误处理部分的代码就不应该被装入内存。因此静态链接、静态装入的方法不但浪费了硬盘空间，同时也浪费了内存空间。由于早期系统的内存资源十分宝贵，所以后者对早期的系统来讲更加致命。]]></description>
				<content:encoded><![CDATA[<p><strong>链接器和装入器的基本工作原理</strong></p>
<p>一个程序要想在内存中运行，除了编译之外还要经过链接和装入这两个步骤。从程序员的角度来看，引入这两个步骤带来的好处就是可以直接在程序中使用printf和errno这种有意义的函数名和变量名，而不用明确指明printf和errno在标准C库中的地址。当然，为了将程序员从早期直接使用地址编程的梦魇中解救出来，编译器和汇编器在这当中做出了革命性的贡献。编译器和汇编器的出现使得程序员可以在程序中使用更具意义的符号来为函数和变量命名，这样使得程序在正确性和可读性等方面都得到了极大的提高。但是随着C语言这种支持分别编译的程序设计语言的流行，一个完整的程序往往被分割为若干个独立的部分并行开发，而各个模块间通过函数接口或全局变量进行通讯。这就带来了一个问题，编译器只能在一个模块内部完成符号名到地址的转换工作，不同模块间的符号解析由谁来做呢？比如前面所举的例子，调用printf的用户程序和实现了printf的标准C库显然就是两个不同的模块。实际上，这个工作是由链接器来完成的。</p>
<p>为了解决不同模块间的链接问题，链接器主要有两个工作要做――符号解析和重定位：</p>
<p><strong>符号解析：</strong>当一个模块使用了在该模块中没有定义过的函数或全局变量时，编译器生成的符号表会标记出所有这样的函数或全局变量，而链接器的责任就是要到别的模块中去查找它们的定义，如果没有找到合适的定义或者找到的合适的定义不唯一，符号解析都无法正常完成。</p>
<p><strong>重定位：</strong>编译器在编译生成目标文件时，通常都使用从零开始的相对地址。然而，在链接过程中，链接器将从一个指定的地址开始，根据输入的目标文件的顺序以段为单位将它们一个接一个的拼装起来。除了目标文件的拼装之外，在重定位的过程中还完成了两个任务：一是生成最终的符号表；二是对代码段中的某些位置进行修改，所有需要修改的位置都由编译器生成的重定位表指出。</p>
<p>举个简单的例子，上面的概念对读者来说就一目了然了。假如我们有一个程序由两部分构成，m.c中的main函数调用f.c中实现的函数sum：</p>

<div class="wp_code"><div class="pre"><pre class="c" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #808080; font-style: italic;">/* m.c */</span>
<span style="color: #993333;">int</span> i <span style="color: #339933;">=</span> <span style="color: #0000dd;">1</span><span style="color: #339933;">;</span>
<span style="color: #993333;">int</span> j <span style="color: #339933;">=</span> <span style="color: #0000dd;">2</span><span style="color: #339933;">;</span>
<span style="color: #000000; font-weight: bold;">extern</span> <span style="color: #993333;">int</span> sum<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #993333;">void</span> main<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span>
<span style="color: #009900;">&#123;</span>
        <span style="color: #993333;">int</span> s<span style="color: #339933;">;</span>
        s <span style="color: #339933;">=</span> sum<span style="color: #009900;">&#40;</span>i<span style="color: #339933;">,</span> j<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span>
&nbsp;
<span style="color: #808080; font-style: italic;">/* f.c */</span>
<span style="color: #993333;">int</span> sum<span style="color: #009900;">&#40;</span><span style="color: #993333;">int</span> i<span style="color: #339933;">,</span> <span style="color: #993333;">int</span> j<span style="color: #009900;">&#41;</span>
<span style="color: #009900;">&#123;</span>
        <span style="color: #b1b100;">return</span> i <span style="color: #339933;">+</span> j<span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>在Linux用gcc分别将两段源程序编译成目标文件：</p>

<div class="wp_code"><div class="pre"><pre class="c" style="font-family:'Times New Roman',Garamond, Times;">$ gcc <span style="color: #339933;">-</span>c m.<span style="color: #202020;">c</span>
$ gcc <span style="color: #339933;">-</span>c f.<span style="color: #202020;">c</span></pre></div></div>

<p>我们通过objdump来看看在编译过程中生成的符号表和重定位表：</p>

<div class="wp_code"><div class="pre"><pre class="c" style="font-family:'Times New Roman',Garamond, Times;">$ objdump <span style="color: #339933;">-</span>x m.<span style="color: #202020;">o</span>
……
SYMBOL TABLE<span style="color: #339933;">:</span>
……
<span style="color: #208080;">00000000</span> g		O .<span style="color: #202020;">data</span>  <span style="color: #208080;">00000004</span> i
<span style="color: #208080;">00000004</span> g		O .<span style="color: #202020;">data</span>  <span style="color: #208080;">00000004</span> j
<span style="color: #208080;">00000000</span> g		F .<span style="color: #202020;">text</span>  <span style="color: #208080;">00000021</span> main
<span style="color: #208080;">00000000</span>         <span style="color: #339933;">*</span>UND<span style="color: #339933;">*</span>  <span style="color: #208080;">00000000</span> sum
RELOCATION RECORDS FOR <span style="color: #009900;">&#91;</span>.<span style="color: #202020;">text</span><span style="color: #009900;">&#93;</span><span style="color: #339933;">:</span>
OFFSET   TYPE              VALUE
<span style="color: #208080;">00000007</span> R_386_32          j
0000000d R_386_32          i
<span style="color: #208080;">00000013</span> R_386_PC32        sum</pre></div></div>

]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7170.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
