<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>java &#8211; 谢子明</title>
	<atom:link href="http://www.xieziming.com/tag/java/feed" rel="self" type="application/rss+xml" />
	<link>http://www.xieziming.com</link>
	<description>Suny Xie</description>
	<lastBuildDate>Mon, 26 Dec 2016 16:05:06 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.7</generator>
	<item>
		<title>JavaOne Conference</title>
		<link>http://www.xieziming.com/archives/8665.html</link>
		<comments>http://www.xieziming.com/archives/8665.html#respond</comments>
		<pubDate>Wed, 24 Jul 2013 12:53:43 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[工作]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=8665</guid>
		<description><![CDATA[<img src="http://images.xieziming.com/upload/2013/07/11/3.jpg" alt="ziming" />]]></description>
				<content:encoded><![CDATA[<p><img src="http://images.xieziming.com/upload/2013/07/11/1.jpg" alt="ziming" /></p>
<p><img src="http://images.xieziming.com/upload/2013/07/11/2.jpg" alt="ziming" /></p>
<p><img src="http://images.xieziming.com/upload/2013/07/11/3.jpg" alt="ziming" /></p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/8665.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java Socket长连接</title>
		<link>http://www.xieziming.com/archives/8506.html</link>
		<comments>http://www.xieziming.com/archives/8506.html#respond</comments>
		<pubDate>Sun, 07 Apr 2013 07:17:20 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=8506</guid>
		<description><![CDATA[这段时间在写PC间通信的一些代码，用的是Java Socket，建长连接的时候总是出现socket中断连接，后来总结了下，发现一定要在服务器端/客户端实现接收和发送两个线程才可避免这个问题。
<code lang="java">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.Socket;

public class Client { 
	....
	private void start() {
		try {
			Socket socket = new Socket(host, port);// 创建Socket
			new Thread(new SendThread(socket)).start();// 启动读线程
			new Thread(new ReceiveThread(socket)).start();// 启动收线程
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public static void main(String[] args) {
		new Client().start();
	}
}
</code>]]></description>
				<content:encoded><![CDATA[<p>这段时间在写PC间通信的一些代码，用的是Java Socket，建长连接的时候总是出现socket中断连接，后来总结了下，发现一定要在服务器端/客户端实现接收和发送两个线程才可避免这个问题。</p>
<p>Server.java</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">import</span> <span style="color: #006699;">java.io.BufferedReader</span><span style="color: #339933;">;</span>
<span style="color: #000000; font-weight: bold;">import</span> <span style="color: #006699;">java.io.IOException</span><span style="color: #339933;">;</span>
<span style="color: #000000; font-weight: bold;">import</span> <span style="color: #006699;">java.io.InputStreamReader</span><span style="color: #339933;">;</span>
<span style="color: #000000; font-weight: bold;">import</span> <span style="color: #006699;">java.io.OutputStreamWriter</span><span style="color: #339933;">;</span>
<span style="color: #000000; font-weight: bold;">import</span> <span style="color: #006699;">java.io.Writer</span><span style="color: #339933;">;</span>
<span style="color: #000000; font-weight: bold;">import</span> <span style="color: #006699;">java.net.ServerSocket</span><span style="color: #339933;">;</span>
<span style="color: #000000; font-weight: bold;">import</span> <span style="color: #006699;">java.net.Socket</span><span style="color: #339933;">;</span>
&nbsp;
&nbsp;
<span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> Server <span style="color: #009900;">&#123;</span>
	<span style="color: #000000; font-weight: bold;">private</span> <span style="color: #003399;">ServerSocket</span> serverSocket<span style="color: #339933;">;</span>
	<span style="color: #000000; font-weight: bold;">private</span> <span style="color: #003399;">Socket</span> socket<span style="color: #339933;">;</span>
	<span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000066; font-weight: bold;">int</span> port <span style="color: #339933;">=</span> <span style="color: #cc66cc;">5055</span><span style="color: #339933;">;</span>
&nbsp;
	<span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000066; font-weight: bold;">void</span> start<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #000000; font-weight: bold;">throws</span> <span style="color: #003399;">Exception</span> <span style="color: #009900;">&#123;</span>
		serverSocket <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> <span style="color: #003399;">ServerSocket</span><span style="color: #009900;">&#40;</span>port<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
		<span style="color: #000000; font-weight: bold;">while</span> <span style="color: #009900;">&#40;</span><span style="color: #000066; font-weight: bold;">true</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
			socket <span style="color: #339933;">=</span> serverSocket.<span style="color: #006633;">accept</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
			<span style="color: #000000; font-weight: bold;">new</span> <span style="color: #003399;">Thread</span><span style="color: #009900;">&#40;</span><span style="color: #000000; font-weight: bold;">new</span> SocketThread<span style="color: #009900;">&#40;</span>socket<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span>.<span style="color: #006633;">start</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
		<span style="color: #009900;">&#125;</span>
	<span style="color: #009900;">&#125;</span>
&nbsp;
	<span style="color: #008000; font-style: italic; font-weight: bold;">/**
	 * 处理socket连接s
	 */</span>
	<span style="color: #000000; font-weight: bold;">class</span> SocketThread <span style="color: #000000; font-weight: bold;">implements</span> <span style="color: #003399;">Runnable</span> <span style="color: #009900;">&#123;</span>
		<span style="color: #000000; font-weight: bold;">private</span> <span style="color: #003399;">Socket</span> socket<span style="color: #339933;">;</span>
&nbsp;
		<span style="color: #000000; font-weight: bold;">public</span> SocketThread<span style="color: #009900;">&#40;</span><span style="color: #003399;">Socket</span> socket<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
			<span style="color: #000000; font-weight: bold;">this</span>.<span style="color: #006633;">socket</span> <span style="color: #339933;">=</span> socket<span style="color: #339933;">;</span>
		<span style="color: #009900;">&#125;</span>
&nbsp;
		<span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">void</span> run<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
			<span style="color: #000000; font-weight: bold;">try</span> <span style="color: #009900;">&#123;</span>
				<span style="color: #003399;">BufferedReader</span> reader <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> <span style="color: #003399;">BufferedReader</span><span style="color: #009900;">&#40;</span><span style="color: #000000; font-weight: bold;">new</span> <span style="color: #003399;">InputStreamReader</span><span style="color: #009900;">&#40;</span>socket.<span style="color: #006633;">getInputStream</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
				<span style="color: #003399;">Writer</span> writer <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> <span style="color: #003399;">OutputStreamWriter</span><span style="color: #009900;">&#40;</span>socket.<span style="color: #006633;">getOutputStream</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
				<span style="color: #003399;">String</span> content<span style="color: #339933;">;</span>
				<span style="color: #000000; font-weight: bold;">while</span> <span style="color: #009900;">&#40;</span><span style="color: #009900;">&#40;</span>content <span style="color: #339933;">=</span> reader.<span style="color: #006633;">readLine</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span> <span style="color: #339933;">!=</span> <span style="color: #000066; font-weight: bold;">null</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
					<span style="color: #003399;">System</span>.<span style="color: #006633;">out</span>.<span style="color: #006633;">println</span><span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;receive:&quot;</span> <span style="color: #339933;">+</span> content<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
					writer.<span style="color: #006633;">write</span><span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;this is server <span style="color: #000099; font-weight: bold;">\r</span><span style="color: #000099; font-weight: bold;">\n</span>&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
					writer.<span style="color: #006633;">flush</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
				<span style="color: #009900;">&#125;</span>
			<span style="color: #009900;">&#125;</span> <span style="color: #000000; font-weight: bold;">catch</span> <span style="color: #009900;">&#40;</span><span style="color: #003399;">IOException</span> e<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
				e.<span style="color: #006633;">printStackTrace</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
			<span style="color: #009900;">&#125;</span> <span style="color: #000000; font-weight: bold;">finally</span> <span style="color: #009900;">&#123;</span>
				<span style="color: #000000; font-weight: bold;">if</span> <span style="color: #009900;">&#40;</span>socket <span style="color: #339933;">!=</span> <span style="color: #000066; font-weight: bold;">null</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
					<span style="color: #000000; font-weight: bold;">if</span> <span style="color: #009900;">&#40;</span><span style="color: #339933;">!</span>socket.<span style="color: #006633;">isClosed</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
						<span style="color: #000000; font-weight: bold;">try</span> <span style="color: #009900;">&#123;</span>
							socket.<span style="color: #006633;">close</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
						<span style="color: #009900;">&#125;</span> <span style="color: #000000; font-weight: bold;">catch</span> <span style="color: #009900;">&#40;</span><span style="color: #003399;">IOException</span> e<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
							e.<span style="color: #006633;">printStackTrace</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
						<span style="color: #009900;">&#125;</span>
					<span style="color: #009900;">&#125;</span>
				<span style="color: #009900;">&#125;</span>
&nbsp;
			<span style="color: #009900;">&#125;</span>
		<span style="color: #009900;">&#125;</span>
&nbsp;
	<span style="color: #009900;">&#125;</span>
&nbsp;
	<span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">static</span> <span style="color: #000066; font-weight: bold;">void</span> main<span style="color: #009900;">&#40;</span><span style="color: #003399;">String</span><span style="color: #009900;">&#91;</span><span style="color: #009900;">&#93;</span> args<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
		Server s <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> Server<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
		<span style="color: #000000; font-weight: bold;">try</span> <span style="color: #009900;">&#123;</span>
			s.<span style="color: #006633;">start</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
		<span style="color: #009900;">&#125;</span> <span style="color: #000000; font-weight: bold;">catch</span> <span style="color: #009900;">&#40;</span><span style="color: #003399;">Exception</span> e<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
			e.<span style="color: #006633;">printStackTrace</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
		<span style="color: #009900;">&#125;</span>
	<span style="color: #009900;">&#125;</span>
&nbsp;
<span style="color: #009900;">&#125;</span></pre></div></div>

]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/8506.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java源码混淆</title>
		<link>http://www.xieziming.com/archives/8811.html</link>
		<comments>http://www.xieziming.com/archives/8811.html#respond</comments>
		<pubDate>Sat, 17 Nov 2012 08:43:19 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://ideashot.com/?p=8811</guid>
		<description><![CDATA[Java程序的编译过程与C／C++程序的编译过程截然不同。C／C++程序经编译后生成的是二进制的机器码，这种代码只有在特定平台上才能运行，通过查找表编译器可以将所有变量和方法符号的引用转换成特定的内存偏移量。而Java编译器却既不能把变量和方法等符号的引用转换为数值引用，也不能确定程序执行过程中的内存布局，而是将这些符号的引用信息保留在class文件中，由解释器在运行过程中创建内存布局，然后再通过查找表来确定一个变量或方法所在的地址。

因此Java字节码文件中保留了所有方法和变量的信息符号，而这些符号根据编码规则通常带有语义信息，这就为反编译Java类文件提供了可能。也正是由于Java本身的这种特性，使得Java类文件很容易被反编译成与原文件非常相似的文件。

代码混淆技术是一种重要的软件保护方法，混淆的实质就是一种变换，通过这种变换把原来的代码变成与其功能相同或相近的，但是更难被理解和反编译的代码。由于混淆技术可以根据不同的目的，不同的混淆对象采用不同的方法，这使得混淆方法非常多。

<strong>代码混淆的分类</strong>

根据混淆变换原理，本文将代码混淆技术分为词法变换、控制混淆、数据混淆和类结构混淆，以下将分别对这四种混淆技术加以阐述。

<strong>词法变换</strong>
词法变换的原理是对函数和变量的名称进行变换，使其违背Java命名规范中见名知义的原则。其原理依照Java虚拟机规范中有关类文件结构的规定，对常量池中存储的类、字段、方法和变量等名称的“CONSTANT Utf8 info"类型的数据项加以混淆，在保持程序语义不变的前提下将名字更改为毫无意义、无规律的字符串。这种方法具有单向性，并且没有引入额外的执行代价。目前Java字节码混淆器和混淆编译器大多支持这一功能。

为了提高混淆算法的隐蔽性，Roo和Oord提出了使用标识符交换来进行词法变换，其思想是用标识符作交换而非更改成毫无意义的名字。标识符交换包括交换变量名、函数名和类型三种。使用标识符交换来进行词法变换在提高隐蔽性的同时，由于标识符的保留也为反编译者提供了方便，不具有单向性。]]></description>
				<content:encoded><![CDATA[<p>Java程序的编译过程与C／C++程序的编译过程截然不同。C／C++程序经编译后生成的是二进制的机器码，这种代码只有在特定平台上才能运行，通过查找表编译器可以将所有变量和方法符号的引用转换成特定的内存偏移量。而Java编译器却既不能把变量和方法等符号的引用转换为数值引用，也不能确定程序执行过程中的内存布局，而是将这些符号的引用信息保留在class文件中，由解释器在运行过程中创建内存布局，然后再通过查找表来确定一个变量或方法所在的地址。</p>
<p>因此Java字节码文件中保留了所有方法和变量的信息符号，而这些符号根据编码规则通常带有语义信息，这就为反编译Java类文件提供了可能。也正是由于Java本身的这种特性，使得Java类文件很容易被反编译成与原文件非常相似的文件。</p>
<p>代码混淆技术是一种重要的软件保护方法，混淆的实质就是一种变换，通过这种变换把原来的代码变成与其功能相同或相近的，但是更难被理解和反编译的代码。由于混淆技术可以根据不同的目的，不同的混淆对象采用不同的方法，这使得混淆方法非常多。</p>
<p><strong>代码混淆的分类</strong></p>
<p>根据混淆变换原理，本文将代码混淆技术分为词法变换、控制混淆、数据混淆和类结构混淆，以下将分别对这四种混淆技术加以阐述。</p>
<p><strong>词法变换</strong><br />
词法变换的原理是对函数和变量的名称进行变换，使其违背Java命名规范中见名知义的原则。其原理依照Java虚拟机规范中有关类文件结构的规定，对常量池中存储的类、字段、方法和变量等名称的“CONSTANT Utf8 info&#8221;类型的数据项加以混淆，在保持程序语义不变的前提下将名字更改为毫无意义、无规律的字符串。这种方法具有单向性，并且没有引入额外的执行代价。目前Java字节码混淆器和混淆编译器大多支持这一功能。</p>
<p>为了提高混淆算法的隐蔽性，Roo和Oord提出了使用标识符交换来进行词法变换，其思想是用标识符作交换而非更改成毫无意义的名字。标识符交换包括交换变量名、函数名和类型三种。使用标识符交换来进行词法变换在提高隐蔽性的同时，由于标识符的保留也为反编译者提供了方便，不具有单向性。</p>
<p><strong>控制混淆</strong></p>
<p>控制混淆是一种被广泛使用的代码混淆技术，其基本原理是通过改变程序的判断条件，或向程序中添加不透明谓词等方法来增加程序的复杂度，并且可以通过对程序结构和执行路径的调整，来增加反编译工具反编译程序的难度。目前较为流行的控制混淆变换主要有以下几种：分支插入变换、循环条件插入变换、将可化简的控制流转换成不可化简的控制流、使用对象和别名的不透明谓词和使用并行技术构建不透明谓词等。</p>
<p>不透明谓词：一个谓词P在P点若其值在混淆时，混淆者可知而反编译者 很难获知，则称它为不透明谓词。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/8811.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>制作Java Applet签名</title>
		<link>http://www.xieziming.com/archives/8807.html</link>
		<comments>http://www.xieziming.com/archives/8807.html#respond</comments>
		<pubDate>Sat, 17 Nov 2012 08:37:20 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://ideashot.com/?p=8807</guid>
		<description><![CDATA[(1)将java小程序打包 
<code lang="java">
jar cvf test.jar test.class
</code>
(2)生成名为chinani.store的密钥库,别名为chinani 
<code lang="java">
keytool -genkey -keystore chinani.store -alias chinani
</code>
密码：123456 (该密码及以后出现的密码都需要自己输入) 以下根据需要输入，最后确认：y
(3)导出chinani.cer数字证书 
<code lang="java">
keytool -export -keystore chinani.store -alias chinani -file chinani.cer
</code>

(4)对test.jar文件进行签名 
<code lang="java">
jarsigner -keystore chinani.store  test.jar chinani
</code>

最后写一个html文件，运行此文件即可自动下载安装运行java小程序HTML文件内容如下：
<code lang="html">
<applet code=Test archive="Test.jar" width=320 height=300></applet>
</code>]]></description>
				<content:encoded><![CDATA[<p>怎样对java小程序签名受到很多人的关注，网上也有这些方面可供参考的文档，但都不是完整，在这里我给出一份可具体操作的文档，希望能给大家一些帮助。 </p>
<p>场景：test.jar：内含待签名的java小程序 结果：签名后，客户端能自动下载java小程序，且java小程序能访问客户端的任何资源</p>
<p>步骤：</p>
<p>(1)将java小程序打包</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;">jar cvf test.<span style="color: #006633;">jar</span> test.<span style="color: #000000; font-weight: bold;">class</span></pre></div></div>

<p>(2)生成名为chinani.store的密钥库,别名为chinani</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;">keytool <span style="color: #339933;">-</span>genkey <span style="color: #339933;">-</span>keystore chinani.<span style="color: #006633;">store</span> <span style="color: #339933;">-</span>alias chinani</pre></div></div>

<p>密码：123456 (该密码及以后出现的密码都需要自己输入) 以下根据需要输入，最后确认：y<br />
(3)导出chinani.cer数字证书</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;">keytool <span style="color: #339933;">-</span>export <span style="color: #339933;">-</span>keystore chinani.<span style="color: #006633;">store</span> <span style="color: #339933;">-</span>alias chinani <span style="color: #339933;">-</span>file chinani.<span style="color: #006633;">cer</span></pre></div></div>

<p>(4)对test.jar文件进行签名</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;">jarsigner <span style="color: #339933;">-</span>keystore chinani.<span style="color: #006633;">store</span>  test.<span style="color: #006633;">jar</span> chinani</pre></div></div>

<p>最后写一个html文件，运行此文件即可自动下载安装运行java小程序HTML文件内容如下：</p>

<div class="wp_code"><div class="pre"><pre class="html" style="font-family:'Times New Roman',Garamond, Times;">&lt;applet code=Test archive=&quot;Test.jar&quot; width=320 height=300&gt;&lt;/applet&gt;</pre></div></div>

]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/8807.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java源码加/解密</title>
		<link>http://www.xieziming.com/archives/8804.html</link>
		<comments>http://www.xieziming.com/archives/8804.html#respond</comments>
		<pubDate>Sat, 17 Nov 2012 08:24:18 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://ideashot.com/?p=8804</guid>
		<description><![CDATA[对于传统的C或C++之类的语言来说，要在Web上保护源代码是很容易的，只要不发布它就可以。遗憾的是，Java程序的源代码很容易被别人偷看。只要有一个反编译器，任何人都可以分析别人的代码。Java的灵活性使得源代码很容易被窃取，但与此同时，它也使通过加密保护代码变得相对容易，我们唯一需要了解的就是Java的ClassLoader对象。当然，在加密过程中，有关Java Cryptography Extension（JCE）的知识也是必不可少的。

有几种技术可以“模糊”Java类文件，使得反编译器处理类文件的效果大打折扣。然而，修改反编译器使之能够处理这些经过模糊处理的类文件并不是什么难事，所以不能简单地依赖模糊技术来保证源代码的安全。

我们可以用流行的加密工具加密应用，比如PGP（Pretty Good Privacy）或GPG（GNU Privacy Guard）。这时，最终用户在运行应用之前必须先进行解密。但解密之后，最终用户就有了一份不加密的类文件，这和事先不进行加密没有什么差别。

Java运行时装入字节码的机制隐含地意味着可以对字节码进行修改。JVM每次装入类文件时都需要一个称为ClassLoader的对象，这个对象负责把新的类装入正在运行的JVM。JVM给ClassLoader一个包含了待装入类（比如java.lang.Object）名字的字符串，然后由ClassLoader负责找到类文件，装入原始数据，并把它转换成一个Class对象。

我们可以通过定制ClassLoader，在类文件执行之前修改它。这种技术的应用非常广泛――在这里，它的用途是在类文件装入之时进行解密，因此可以看成是一种即时解密器。由于解密后的字节码文件永远不会保存到文件系统，所以窃密者很难得到解密后的代码。

由于把原始字节码转换成Class对象的过程完全由系统负责，所以创建定制ClassLoader对象其实并不困难，只需先获得原始数据，接着就可以进行包含解密在内的任何转换。]]></description>
				<content:encoded><![CDATA[<p><strong>为什么要加密？</strong></p>
<p>对于传统的C或C++之类的语言来说，要在Web上保护源代码是很容易的，只要不发布它就可以。遗憾的是，Java程序的源代码很容易被别人偷看。只要有一个反编译器，任何人都可以分析别人的代码。Java的灵活性使得源代码很容易被窃取，但与此同时，它也使通过加密保护代码变得相对容易，我们唯一需要了解的就是Java的ClassLoader对象。当然，在加密过程中，有关Java Cryptography Extension（JCE）的知识也是必不可少的。</p>
<p>有几种技术可以“模糊”Java类文件，使得反编译器处理类文件的效果大打折扣。然而，修改反编译器使之能够处理这些经过模糊处理的类文件并不是什么难事，所以不能简单地依赖模糊技术来保证源代码的安全。</p>
<p>我们可以用流行的加密工具加密应用，比如PGP（Pretty Good Privacy）或GPG（GNU Privacy Guard）。这时，最终用户在运行应用之前必须先进行解密。但解密之后，最终用户就有了一份不加密的类文件，这和事先不进行加密没有什么差别。</p>
<p>Java运行时装入字节码的机制隐含地意味着可以对字节码进行修改。JVM每次装入类文件时都需要一个称为ClassLoader的对象，这个对象负责把新的类装入正在运行的JVM。JVM给ClassLoader一个包含了待装入类（比如java.lang.Object）名字的字符串，然后由ClassLoader负责找到类文件，装入原始数据，并把它转换成一个Class对象。</p>
<p>我们可以通过定制ClassLoader，在类文件执行之前修改它。这种技术的应用非常广泛――在这里，它的用途是在类文件装入之时进行解密，因此可以看成是一种即时解密器。由于解密后的字节码文件永远不会保存到文件系统，所以窃密者很难得到解密后的代码。</p>
<p>由于把原始字节码转换成Class对象的过程完全由系统负责，所以创建定制ClassLoader对象其实并不困难，只需先获得原始数据，接着就可以进行包含解密在内的任何转换。</p>
<p>Java 2在一定程度上简化了定制ClassLoader的构建。在Java 2中，loadClass的缺省实现仍旧负责处理所有必需的步骤，但为了顾及各种定制的类装入过程，它还调用一个新的findClass方法。</p>
<p>这为我们编写定制的ClassLoader提供了一条捷径，减少了麻烦：只需覆盖findClass，而不是覆盖loadClass。这种方法避免了重复所有装入器必需执行的公共步骤，因为这一切由loadClass负责。</p>
<p>不过，本文的定制ClassLoader并不使用这种方法。原因很简单。如果由默认的ClassLoader先寻找经过加密的类文件，它可以找到；但由于类文件已经加密，所以它不会认可这个类文件，装入过程将失败。因此，我们必须自己实现loadClass，稍微增加了一些工作量。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/8804.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>质疑和反驳</title>
		<link>http://www.xieziming.com/archives/7605.html</link>
		<comments>http://www.xieziming.com/archives/7605.html#respond</comments>
		<pubDate>Sun, 04 Nov 2012 03:46:29 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[网摘]]></category>
		<category><![CDATA[java]]></category>
		<category><![CDATA[Summary]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7605</guid>
		<description><![CDATA[“所有程序员都会写自己看得懂的代码，但只有优秀的程序员才写大家看得懂的代码。”

更重要的是，要代码能够“看得懂”，主要是靠足够多的注释吗？扯淡！

反对我的人会说，软件公司做产品赚钱，它们希望你的代码让不熟悉项目的新员工快速阅读、上手。这确实是个矛盾。说白了，你写的代码要和一个团队的能力匹配。在一个鱼龙混杂的团队，甚至一个糟糕的团队，你写出的代码也许很难和大伙儿产生共鸣，他们希望你写最普通最易懂的代码，没有精巧的设计（我指的是，“某一些精巧的设计，恰恰是以降低代码的可维护性为代价的”），没有语言高级特性，看着只有顺序、循环、分支判断的基本代码。

所以许多上进的程序员，会希望在一个牛人的团队里工作。这就像足球运动员一样，因为足球是集体运动，一个足球运动员能达到的高度，是和他所在的团队息息相关的。在一个优秀的团队里，大家个性各有千秋，擅长领域不甚相同，但是都学习迅速，能力不差太远，大家阅读代码都能够很快理解和领会，而且讨论问题可以用一些程序员才明白的隐喻（比如有人说“我觉得这里应该用一个builder来实现”，大家都明白builder指的是什么），氛围和效率显而易见。

如果你恰好对当前需要用到的业务和技术特别熟悉，领先团队里其他人一大截怎么办？那你就该在做设计编码的时候先行一步，<strong>你是那个最该去做架构设计、写骨架代码的人，完成一个架子以后再来给大家讲解，并和大家讨论，改进现有的设计。</strong>也就是说，你要多做一些更重要的事，而不是和大家一起分析、一起讨论，甚至一人负责一个模块，最后的结果就是大家根本和你讨论不到一块儿去。]]></description>
				<content:encoded><![CDATA[<font color="#00BB00"><strong>为代码写足够的注释，让代码易于理解</strong></font>
<p>“所有程序员都会写自己看得懂的代码，但只有优秀的程序员才写大家看得懂的代码。”</p>
<p>这话没错，但是——什么才是“大家看得懂”的定义？我有必要让我的C++代码对于一个月前才明白指针和引用区别的初学者简单易懂么？</p>
<p>更重要的是，要代码能够“看得懂”，主要是靠足够多的注释吗？扯淡！</p>
<p>反对我的人会说，软件公司做产品赚钱，它们希望你的代码让不熟悉项目的新员工快速阅读、上手。这确实是个矛盾。说白了，你写的代码要和一个团队的能力匹配。在一个鱼龙混杂的团队，甚至一个糟糕的团队，你写出的代码也许很难和大伙儿产生共鸣，他们希望你写最普通最易懂的代码，没有精巧的设计（我指的是，“某一些精巧的设计，恰恰是以降低代码的可维护性为代价的”），没有语言高级特性，看着只有顺序、循环、分支判断的基本代码。</p>
<p>所以许多上进的程序员，会希望在一个牛人的团队里工作。这就像足球运动员一样，因为足球是集体运动，一个足球运动员能达到的高度，是和他所在的团队息息相关的。在一个优秀的团队里，大家个性各有千秋，擅长领域不甚相同，但是都学习迅速，能力不差太远，大家阅读代码都能够很快理解和领会，而且讨论问题可以用一些程序员才明白的隐喻（比如有人说“我觉得这里应该用一个builder来实现”，大家都明白builder指的是什么），氛围和效率显而易见。</p>
<p>如果你恰好对当前需要用到的业务和技术特别熟悉，领先团队里其他人一大截怎么办？那你就该在做设计编码的时候先行一步，<strong>你是那个最该去做架构设计、写骨架代码的人，完成一个架子以后再来给大家讲解，并和大家讨论，改进现有的设计。</strong>也就是说，你要多做一些更重要的事，而不是和大家一起分析、一起讨论，甚至一人负责一个模块，最后的结果就是大家根本和你讨论不到一块儿去。</p>
<p>要代码“看得懂”，是设计出来的，而不是注释加出来的。这和产品质量一样，产品质量是设计出来的，而不是测试测出来的。注释的意义在于对当前代码自解释做不到的地方进行补充。</p>
<p>所以，你的代码要易于理解，首先要保持简洁和清晰，这既包括良好的设计，也包括良好的编码习惯，也就是说，代码是自解释的，其次才通过注释的补充，让代码更易懂。注意，我不是说注释不重要和不必要，而是说，注释应该完成它自己的功用，它远不能代替代码本身自我解释的价值。</p>
<p>举一个简单的例子，你可以这样写代码：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #008000; font-style: italic; font-weight: bold;">/**
 * 图表模型
 */</span>
<span style="color: #000000; font-weight: bold;">class</span> Chart<span style="color: #009900;">&#123;</span>
    <span style="color: #008000; font-style: italic; font-weight: bold;">/**
     * 图表长度
     */</span>
    <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000066; font-weight: bold;">int</span> length<span style="color: #339933;">;</span>   
&nbsp;
    <span style="color: #008000; font-style: italic; font-weight: bold;">/**
     * 获取图表长度
     * @return 图表长度
     */</span>
    <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">int</span> getLength<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>
        <span style="color: #000000; font-weight: bold;">return</span> <span style="color: #000000; font-weight: bold;">this</span>.<span style="color: #006633;">length</span><span style="color: #339933;">;</span>
    <span style="color: #009900;">&#125;</span> 
&nbsp;
    <span style="color: #008000; font-style: italic; font-weight: bold;">/**
     * 设置图表长度
     * @param length 图表长度
     */</span>
&nbsp;
    <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">void</span> setLength<span style="color: #009900;">&#40;</span><span style="color: #000066; font-weight: bold;">int</span> length<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>
        <span style="color: #000000; font-weight: bold;">this</span>.<span style="color: #006633;">length</span> <span style="color: #339933;">=</span> length<span style="color: #339933;">;</span>
    <span style="color: #009900;">&#125;</span>
<span style="color: #009900;">&#125;</span></pre></div></div>

]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7605.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java集合类</title>
		<link>http://www.xieziming.com/archives/7545.html</link>
		<comments>http://www.xieziming.com/archives/7545.html#respond</comments>
		<pubDate>Sun, 21 Oct 2012 03:46:43 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7545</guid>
		<description><![CDATA[Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些 Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。 
　　　　
如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下： 
<code lang="java">
Iterator it = collection.iterator(); // 获得一个迭代子 
while(it.hasNext()) { 
　　Object obj = it.next(); // 得到下一个元素 
} 
</code>
由Collection接口派生的两个接口是List和Set。 

<strong>List接口</strong> 
List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。 和下面要提到的Set不同，List允许有相同的元素。 

除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个 ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历。 ]]></description>
				<content:encoded><![CDATA[<p>Java集合类主要负责保存、盛装其他数据，因此集合类也称容器类。java集合类分为：set、list、map、queue四大体系。其中set代表无序、不可重复的集合；list代表有序、可重复的集合。map代表具有映射关系的集合；queue代表队列集合。</p>
<p>Java集合类主要由两个接口派生：Collection和Map，是集合框架的根接口。</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #003399;">Collection</span> 
├<span style="color: #003399;">List</span> 
│├<span style="color: #003399;">LinkedList</span> 
│├<span style="color: #003399;">ArrayList</span> 
│└<span style="color: #003399;">Vector</span> 
│　└<span style="color: #003399;">Stack</span> 
│
├Queue
│├Dueue
│　└ArrayDueue
│　└<span style="color: #003399;">LinkedList</span>
│
└<span style="color: #003399;">Set</span> 
&nbsp;
<span style="color: #003399;">Map</span> 
├<span style="color: #003399;">Hashtable</span> 
├<span style="color: #003399;">HashMap</span> 
├<span style="color: #003399;">WeakHashMap</span>
└<span style="color: #003399;">TreeMap</span></pre></div></div>

<p><strong>Collection接口</strong><br />
Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些 Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。<br />
　　　　<br />
如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #003399;">Iterator</span> it <span style="color: #339933;">=</span> collection.<span style="color: #006633;">iterator</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">// 获得一个迭代子 </span>
<span style="color: #000000; font-weight: bold;">while</span><span style="color: #009900;">&#40;</span>it.<span style="color: #006633;">hasNext</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> 
　　<span style="color: #003399;">Object</span> obj <span style="color: #339933;">=</span> it.<span style="color: #006633;">next</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">// 得到下一个元素 </span>
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>由Collection接口派生的两个接口是List和Set。 </p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7545.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java自动装箱</title>
		<link>http://www.xieziming.com/archives/7527.html</link>
		<comments>http://www.xieziming.com/archives/7527.html#respond</comments>
		<pubDate>Sun, 14 Oct 2012 10:58:16 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7527</guid>
		<description><![CDATA[在Java中，数据类型可以分为两大种，基本数据类型（值类型）和类类型（引用数据类型）。基本类型的数值不是对象，不能作为对象调用其toString()、hashCode()、getClass()、equals()等等方法。

所谓装箱，就是把基本类型用它们相对应的引用类型包起来，使它们可以具有对象的特质，如我们可以把int型包装成Integer类的对象，或者把double包装成Double，等等。

所谓拆箱，就是跟装箱的方向相反，将Integer及Double这样的引用类型的对象重新简化为值类型的数据。

装箱和拆箱是valueOf和xxValue的别名。
<code lang="java">
int i=10;
Integer j=new Integer(i); //手动装箱操作
int i1=j.intValue();//手动拆箱操作，拆箱调用了wrapper类的xxxValueOf()方法，所以记住此时不允许wrapper类的对象为null。

Integer j=i;//自动装箱操作 Integer j=Integer.valueOf(10);
int k=j;//自动拆箱操作
</code>]]></description>
				<content:encoded><![CDATA[<p>在Java中，数据类型可以分为两大种，基本数据类型（值类型）和类类型（引用数据类型）。基本类型的数值不是对象，不能作为对象调用其toString()、hashCode()、getClass()、equals()等等方法。</p>
<p>所谓装箱，就是把基本类型用它们相对应的引用类型包起来，使它们可以具有对象的特质，如我们可以把int型包装成Integer类的对象，或者把double包装成Double，等等。</p>
<p>所谓拆箱，就是跟装箱的方向相反，将Integer及Double这样的引用类型的对象重新简化为值类型的数据。</p>
<p>装箱和拆箱是valueOf和xxValue的别名。</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000066; font-weight: bold;">int</span> i<span style="color: #339933;">=</span><span style="color: #cc66cc;">10</span><span style="color: #339933;">;</span>
<span style="color: #003399;">Integer</span> j<span style="color: #339933;">=</span><span style="color: #000000; font-weight: bold;">new</span> <span style="color: #003399;">Integer</span><span style="color: #009900;">&#40;</span>i<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">//手动装箱操作</span>
<span style="color: #000066; font-weight: bold;">int</span> i1<span style="color: #339933;">=</span>j.<span style="color: #006633;">intValue</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span><span style="color: #666666; font-style: italic;">//手动拆箱操作，拆箱调用了wrapper类的xxxValueOf()方法，所以记住此时不允许wrapper类的对象为null。</span>
&nbsp;
<span style="color: #003399;">Integer</span> j<span style="color: #339933;">=</span>i<span style="color: #339933;">;</span><span style="color: #666666; font-style: italic;">//自动装箱操作 Integer j=Integer.valueOf(10);</span>
<span style="color: #000066; font-weight: bold;">int</span> k<span style="color: #339933;">=</span>j<span style="color: #339933;">;</span><span style="color: #666666; font-style: italic;">//自动拆箱操作</span></pre></div></div>


<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> EqualsDemo <span style="color: #009900;">&#123;</span>
    <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">static</span> <span style="color: #000066; font-weight: bold;">void</span> main<span style="color: #009900;">&#40;</span><span style="color: #003399;">String</span><span style="color: #009900;">&#91;</span><span style="color: #009900;">&#93;</span> args<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
        <span style="color: #000066; font-weight: bold;">int</span> i1<span style="color: #339933;">=</span><span style="color: #cc66cc;">1</span>,i2<span style="color: #339933;">=</span><span style="color: #cc66cc;">1</span><span style="color: #339933;">;</span>
        <span style="color: #003399;">Integer</span> iv1<span style="color: #339933;">=</span><span style="color: #cc66cc;">1</span>,iv2<span style="color: #339933;">=</span><span style="color: #cc66cc;">1</span><span style="color: #339933;">;</span>  
        <span style="color: #003399;">Integer</span> in1<span style="color: #339933;">=</span><span style="color: #000000; font-weight: bold;">new</span> <span style="color: #003399;">Integer</span><span style="color: #009900;">&#40;</span><span style="color: #cc66cc;">1</span><span style="color: #009900;">&#41;</span>,in2<span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> <span style="color: #003399;">Integer</span><span style="color: #009900;">&#40;</span><span style="color: #cc66cc;">1</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
        print<span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;(1) &quot;</span> <span style="color: #339933;">+</span> <span style="color: #009900;">&#40;</span>i1<span style="color: #339933;">==</span>i2<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">//(1)</span>
        print<span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;(2) &quot;</span> <span style="color: #339933;">+</span> <span style="color: #009900;">&#40;</span>iv1<span style="color: #339933;">==</span>iv2<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">//(2)</span>
        print<span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;(3) &quot;</span> <span style="color: #339933;">+</span> <span style="color: #009900;">&#40;</span>in1<span style="color: #339933;">==</span>in2<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">//(3)</span>
&nbsp;
        print<span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;(4) &quot;</span> <span style="color: #339933;">+</span> <span style="color: #009900;">&#40;</span>i1<span style="color: #339933;">==</span>iv1<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">//(4)</span>
        print<span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;(5) &quot;</span> <span style="color: #339933;">+</span> <span style="color: #009900;">&#40;</span>i1<span style="color: #339933;">==</span>in1<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">//(5)</span>
        print<span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;(6) &quot;</span> <span style="color: #339933;">+</span> <span style="color: #009900;">&#40;</span>iv1<span style="color: #339933;">==</span>in1<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">//(6)</span>
    <span style="color: #009900;">&#125;</span> 
    <span style="color: #000000; font-weight: bold;">static</span> <span style="color: #000066; font-weight: bold;">void</span> print<span style="color: #009900;">&#40;</span><span style="color: #003399;">Object</span> obj<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>
        <span style="color: #003399;">System</span>.<span style="color: #006633;">out</span>.<span style="color: #006633;">println</span><span style="color: #009900;">&#40;</span>obj<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
    <span style="color: #009900;">&#125;</span>
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>输出结果：<br />
(1) true<br />
(2) true<br />
(3) false<br />
(4) true<br />
(5) true<br />
(6) false</p>
<p>解释：<br />
(1) 基本类型的比较，值和地址都是相等的<br />
(2) 自动装箱，不是调用new来完成，否则地址肯定不相等。</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #003399;">Integer</span> i<span style="color: #339933;">=</span><span style="color: #cc66cc;">1</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">//相当于 Integer i=Integer.valueOf(1);</span>
<span style="color: #008000; font-style: italic; font-weight: bold;">/**
(1)valueOf(int)：返回一个表示指定的int值的Integer实例。如果不需要新的Integer实例，则通常应优先使用该方法，而不是构造方法 
(2)Integer(int)：因为该方法有可能通过缓存经常请求的值而显著提高空间和时间性能。
&nbsp;
Byte,Integer 和Long都是缓存了-128～+127之间的对象，autoboxing的时候，如果需要boxing的值在此范围之内，则直接返回缓存的对象，没有的时候再去new. Boolean类型中直接缓存了两个Boolean对象，true和false，这样使用valueOf()方法时只需要直接返回这两个对象中的一个，而不是每次调用的时候都用new,这也就是文档里所说的通过缓存经常请求的值二显著提高空间和时间性能。
&nbsp;
Character因为类型的特殊性，保存的是0-127之间的对象。
*/</span>
<span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">static</span> <span style="color: #003399;">Integer</span> valueOf<span style="color: #009900;">&#40;</span><span style="color: #000066; font-weight: bold;">int</span> i<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
  <span style="color: #000000; font-weight: bold;">if</span><span style="color: #009900;">&#40;</span>i <span style="color: #339933;">&gt;=</span> <span style="color: #339933;">-</span><span style="color: #cc66cc;">128</span> <span style="color: #339933;">&amp;&amp;</span> i <span style="color: #339933;">&lt;</span> <span style="color: #339933;">=</span> IntegerCache.<span style="color: #006633;">high</span><span style="color: #009900;">&#41;</span>  
    <span style="color: #000000; font-weight: bold;">return</span> IntegerCache.<span style="color: #006633;">cache</span><span style="color: #009900;">&#91;</span>i <span style="color: #339933;">+</span> <span style="color: #cc66cc;">128</span><span style="color: #009900;">&#93;</span><span style="color: #339933;">;</span>  
  <span style="color: #000000; font-weight: bold;">else</span>  
    <span style="color: #000000; font-weight: bold;">return</span> <span style="color: #000000; font-weight: bold;">new</span> <span style="color: #003399;">Integer</span><span style="color: #009900;">&#40;</span>i<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>如果把所有的值都改成1000，输出的结果是：<br />
(1) true<br />
<strong>(2) false</strong><br />
(3) false<br />
(4) true<br />
(5) true<br />
(6) false</p>
<p>发现(2)不再是true，这是因为Integer没有缓存1000这个值。</p>
<p>(3) 调用new来创建实例，地址不相等。如果是equals的话就是true<br />
(4) 发生拆箱，编译之后其实调用了intValue，获得的是基本类型。<br />
(5) 发生拆箱，编译之后其实调用了intValue，获得的是基本类型。<br />
(6) 没有发生拆箱，但要注意下，判断条件如果改为iv1>=in1 或 iv1< =in1，则会发生拆箱，此时为true
</p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7527.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java装饰模式</title>
		<link>http://www.xieziming.com/archives/7515.html</link>
		<comments>http://www.xieziming.com/archives/7515.html#respond</comments>
		<pubDate>Sun, 14 Oct 2012 03:13:53 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7515</guid>
		<description><![CDATA[Decorator(Wrapper)模式的功能是：给一个对象添加一些额外的职责（操作），虽然此功能可以用继承实现，但装饰模式比生成子类更灵活些。 装饰的意思：就是包装一下。把另的对象包装一下。我这里只简单示例下怎么使用。 
 
业务接口 Component： 
<code lang="java">    
/**  
 * 业务接口  
 */    
public interface Component {        
    void operation();    
}  
</code>
具体业务 ConcreteComponent： 
<code lang="java">    
/**  
 * 具体业务类.  
 */    
public class ConcreteComponent implements Component {    
    
    public void operation() {    
        System.out.println("I'm "+this.getClass().getName());    
    } 
}  
</code>]]></description>
				<content:encoded><![CDATA[<p>Decorator(Wrapper)模式的功能是：给一个对象添加一些额外的职责（操作），虽然此功能可以用继承实现，但装饰模式比生成子类更灵活些。 装饰的意思：就是包装一下。把另的对象包装一下。我这里只简单示例下怎么使用。 </p>
<p>业务接口 Component：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #008000; font-style: italic; font-weight: bold;">/**  
 * 业务接口  
 */</span>    
<span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">interface</span> <span style="color: #003399;">Component</span> <span style="color: #009900;">&#123;</span>        
    <span style="color: #000066; font-weight: bold;">void</span> operation<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>    
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>具体业务 ConcreteComponent：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #008000; font-style: italic; font-weight: bold;">/**  
 * 具体业务类.  
 */</span>    
<span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> ConcreteComponent <span style="color: #000000; font-weight: bold;">implements</span> <span style="color: #003399;">Component</span> <span style="color: #009900;">&#123;</span>    
&nbsp;
    <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">void</span> operation<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>    
        <span style="color: #003399;">System</span>.<span style="color: #006633;">out</span>.<span style="color: #006633;">println</span><span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;I'm &quot;</span><span style="color: #339933;">+</span><span style="color: #000000; font-weight: bold;">this</span>.<span style="color: #006633;">getClass</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span>.<span style="color: #006633;">getName</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>    
    <span style="color: #009900;">&#125;</span> 
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>装饰 Decorator：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #008000; font-style: italic; font-weight: bold;">/**  
 * 装饰类.  
 */</span>    
<span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> Decorator <span style="color: #000000; font-weight: bold;">implements</span> <span style="color: #003399;">Component</span> <span style="color: #009900;">&#123;</span>    
&nbsp;
    <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #003399;">Component</span> component<span style="color: #339933;">;</span>    
&nbsp;
    <span style="color: #000000; font-weight: bold;">public</span> Decorator<span style="color: #009900;">&#40;</span><span style="color: #003399;">Component</span> component<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>    
        <span style="color: #000000; font-weight: bold;">this</span>.<span style="color: #006633;">component</span> <span style="color: #339933;">=</span> component<span style="color: #339933;">;</span>    
    <span style="color: #009900;">&#125;</span>    
&nbsp;
    <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">void</span> operation<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>    
        component.<span style="color: #006633;">operation</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>    
    <span style="color: #009900;">&#125;</span>    
&nbsp;
<span style="color: #009900;">&#125;</span></pre></div></div>

]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7515.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java自定义注解</title>
		<link>http://www.xieziming.com/archives/7513.html</link>
		<comments>http://www.xieziming.com/archives/7513.html#respond</comments>
		<pubDate>Sat, 13 Oct 2012 10:48:49 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7513</guid>
		<description><![CDATA[下面是一个使用注解和解析注解(通过反射机制)的实例
<code lang="java">
package Test_annotation;
import java.lang.reflect.Method;
public class Test_1 {
	/*
	 * 被注解的三个方法
	 */
	@Test(id = 1, description = "hello method_1")
	public void method_1() {
	}

	@Test(id = 2)
	public void method_2() {
	}

	@Test(id = 3, description = "last method")
	public void method_3() {
	}

	/*
	 * 解析注解，将Test_1类 所有被注解方法 的信息打印出来
	 */
	public static void main(String[] args) {
		Method[] methods = Test_1.class.getDeclaredMethods();
		for (Method method : methods) {
			/*
			 * 判断方法中是否有指定注解类型的注解
			 */
			boolean hasAnnotation = method.isAnnotationPresent(Test.class);
			if (hasAnnotation) {
				/*
				 * 根据注解类型返回方法的指定类型注解
				 */
				Test annotation = method.getAnnotation(Test.class);
				System.out.println("Test( method = " + method.getName()
						+ " , id = " + annotation.id() + " , description = "
						+ annotation.description() + " )");
			}
		}
	}

}
</code>]]></description>
				<content:encoded><![CDATA[<p>注解（Annotation） 为我们在代码中添加信息提供了一种形式化的方法，是我们可以在稍后某个时刻方便地使用这些数据（通过 解析注解 来使用这些数据）。注解的语法比较简单，除了@符号的使用以外，它基本上与java的固有语法一致，java内置了三种注解，定义在java.lang包中。</p>
<p><strong>@Override</strong>  表示当前方法是覆盖父类的方法。<br />
<strong>@Deprecated</strong>  表示当前元素是不赞成使用的。<br />
<strong>@SuppressWarnings</strong> 表示关闭一些不当的编译器警告信息。</p>
<p>注解主要用于：</p>
<p>(1)编写文档：通过代码里标识的元数据生成文档。<br />
(2)代码分析：通过代码里标识的元数据对代码进行分析。<br />
(3)编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查</p>
<p>要实现一个自定义注解，必须通过 @interface 关键字来定义。且在 @interface 之前，需要通过元注解来描述该注解的使用范围（ @Target ）、生命周期（ @Retention ）及其他。</p>
<p>下面是一个定义注解的实例</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">package</span> <span style="color: #006699;">Test_annotation</span><span style="color: #339933;">;</span>
&nbsp;
<span style="color: #000000; font-weight: bold;">import</span> <span style="color: #006699;">java.lang.annotation.Documented</span><span style="color: #339933;">;</span>
<span style="color: #000000; font-weight: bold;">import</span> <span style="color: #006699;">java.lang.annotation.Inherited</span><span style="color: #339933;">;</span>
<span style="color: #000000; font-weight: bold;">import</span> <span style="color: #006699;">java.lang.annotation.Retention</span><span style="color: #339933;">;</span>
<span style="color: #000000; font-weight: bold;">import</span> <span style="color: #006699;">java.lang.annotation.Target</span><span style="color: #339933;">;</span>
<span style="color: #000000; font-weight: bold;">import</span> <span style="color: #006699;">java.lang.annotation.ElementType</span><span style="color: #339933;">;</span>
<span style="color: #000000; font-weight: bold;">import</span> <span style="color: #006699;">java.lang.annotation.RetentionPolicy</span><span style="color: #339933;">;</span>
&nbsp;
<span style="color: #666666; font-style: italic;">/*
 * 元注解@Target,@Retention,@Documented,@Inherited
 * 
 *     @Target 表示该注解用于什么地方，可能的 ElemenetType 参数包括：
 *         ElemenetType.CONSTRUCTOR 构造器声明
 *         ElemenetType.FIELD 域声明（包括 enum 实例）
 *         ElemenetType.LOCAL_VARIABLE 局部变量声明
 *         ElemenetType.METHOD 方法声明
 *         ElemenetType.PACKAGE 包声明
 *         ElemenetType.PARAMETER 参数声明
 *         ElemenetType.TYPE 类，接口（包括注解类型）或enum声明
 *         
 *     @Retention 表示在什么级别保存该注解信息。可选的 RetentionPolicy 参数包括：
 *         RetentionPolicy.SOURCE 注解将被编译器丢弃
 *         RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃
 *         RetentionPolicy.RUNTIME VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。
 *         
 *     @Documented 将此注解包含在 javadoc 中
 *     
 *     @Inherited 允许子类继承父类中的注解
 *   
 */</span>
@Target<span style="color: #009900;">&#40;</span>ElementType.<span style="color: #006633;">METHOD</span><span style="color: #009900;">&#41;</span>
@Retention<span style="color: #009900;">&#40;</span>RetentionPolicy.<span style="color: #006633;">RUNTIME</span><span style="color: #009900;">&#41;</span>
@Documented
@Inherited
<span style="color: #666666; font-style: italic;">/*
 * 定义注解 Test
 * 注解中含有两个元素 id 和 description
 * description 元素 有默认值 &quot;no description&quot;
 */</span>
<span style="color: #000000; font-weight: bold;">public</span> @<span style="color: #000000; font-weight: bold;">interface</span> Test <span style="color: #009900;">&#123;</span>
	<span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">int</span> id<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
	<span style="color: #000000; font-weight: bold;">public</span> <span style="color: #003399;">String</span> description<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #000000; font-weight: bold;">default</span> <span style="color: #0000ff;">&quot;no description&quot;</span><span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>下面是一个使用注解和解析注解(通过反射机制)的实例</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">package</span> <span style="color: #006699;">Test_annotation</span><span style="color: #339933;">;</span>
<span style="color: #000000; font-weight: bold;">import</span> <span style="color: #006699;">java.lang.reflect.Method</span><span style="color: #339933;">;</span>
<span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> Test_1 <span style="color: #009900;">&#123;</span>
	<span style="color: #666666; font-style: italic;">/*
	 * 被注解的三个方法
	 */</span>
	@Test<span style="color: #009900;">&#40;</span>id <span style="color: #339933;">=</span> <span style="color: #cc66cc;">1</span>, description <span style="color: #339933;">=</span> <span style="color: #0000ff;">&quot;hello method_1&quot;</span><span style="color: #009900;">&#41;</span>
	<span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">void</span> method_1<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
	<span style="color: #009900;">&#125;</span>
&nbsp;
	@Test<span style="color: #009900;">&#40;</span>id <span style="color: #339933;">=</span> <span style="color: #cc66cc;">2</span><span style="color: #009900;">&#41;</span>
	<span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">void</span> method_2<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
	<span style="color: #009900;">&#125;</span>
&nbsp;
	@Test<span style="color: #009900;">&#40;</span>id <span style="color: #339933;">=</span> <span style="color: #cc66cc;">3</span>, description <span style="color: #339933;">=</span> <span style="color: #0000ff;">&quot;last method&quot;</span><span style="color: #009900;">&#41;</span>
	<span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">void</span> method_3<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
	<span style="color: #009900;">&#125;</span>
&nbsp;
	<span style="color: #666666; font-style: italic;">/*
	 * 解析注解，将Test_1类 所有被注解方法 的信息打印出来
	 */</span>
	<span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">static</span> <span style="color: #000066; font-weight: bold;">void</span> main<span style="color: #009900;">&#40;</span><span style="color: #003399;">String</span><span style="color: #009900;">&#91;</span><span style="color: #009900;">&#93;</span> args<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
		<span style="color: #003399;">Method</span><span style="color: #009900;">&#91;</span><span style="color: #009900;">&#93;</span> methods <span style="color: #339933;">=</span> Test_1.<span style="color: #000000; font-weight: bold;">class</span>.<span style="color: #006633;">getDeclaredMethods</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
		<span style="color: #000000; font-weight: bold;">for</span> <span style="color: #009900;">&#40;</span><span style="color: #003399;">Method</span> method <span style="color: #339933;">:</span> methods<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
			<span style="color: #666666; font-style: italic;">/*
			 * 判断方法中是否有指定注解类型的注解
			 */</span>
			<span style="color: #000066; font-weight: bold;">boolean</span> hasAnnotation <span style="color: #339933;">=</span> method.<span style="color: #006633;">isAnnotationPresent</span><span style="color: #009900;">&#40;</span>Test.<span style="color: #000000; font-weight: bold;">class</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
			<span style="color: #000000; font-weight: bold;">if</span> <span style="color: #009900;">&#40;</span>hasAnnotation<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
				<span style="color: #666666; font-style: italic;">/*
				 * 根据注解类型返回方法的指定类型注解
				 */</span>
				Test annotation <span style="color: #339933;">=</span> method.<span style="color: #006633;">getAnnotation</span><span style="color: #009900;">&#40;</span>Test.<span style="color: #000000; font-weight: bold;">class</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
				<span style="color: #003399;">System</span>.<span style="color: #006633;">out</span>.<span style="color: #006633;">println</span><span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;Test( method = &quot;</span> <span style="color: #339933;">+</span> method.<span style="color: #006633;">getName</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span>
						<span style="color: #339933;">+</span> <span style="color: #0000ff;">&quot; , id = &quot;</span> <span style="color: #339933;">+</span> annotation.<span style="color: #006633;">id</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #339933;">+</span> <span style="color: #0000ff;">&quot; , description = &quot;</span>
						<span style="color: #339933;">+</span> annotation.<span style="color: #006633;">description</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #339933;">+</span> <span style="color: #0000ff;">&quot; )&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
			<span style="color: #009900;">&#125;</span>
		<span style="color: #009900;">&#125;</span>
	<span style="color: #009900;">&#125;</span>
&nbsp;
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>输出结果如下：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;">Test<span style="color: #009900;">&#40;</span> method <span style="color: #339933;">=</span> method_1 , id <span style="color: #339933;">=</span> <span style="color: #cc66cc;">1</span> , description <span style="color: #339933;">=</span> hello method_1 <span style="color: #009900;">&#41;</span>
Test<span style="color: #009900;">&#40;</span> method <span style="color: #339933;">=</span> method_2 , id <span style="color: #339933;">=</span> <span style="color: #cc66cc;">2</span> , description <span style="color: #339933;">=</span> no description <span style="color: #009900;">&#41;</span>
Test<span style="color: #009900;">&#40;</span> method <span style="color: #339933;">=</span> method_3 , id <span style="color: #339933;">=</span> <span style="color: #cc66cc;">3</span> , description <span style="color: #339933;">=</span> last method <span style="color: #009900;">&#41;</span></pre></div></div>

]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7513.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java枚举类</title>
		<link>http://www.xieziming.com/archives/7511.html</link>
		<comments>http://www.xieziming.com/archives/7511.html#respond</comments>
		<pubDate>Sat, 13 Oct 2012 10:00:33 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7511</guid>
		<description><![CDATA[1、Color枚举类是特殊的class，其枚举值(RED,BLUE...)是Color的类对象(类实例)：
<code lang="java"> 
Color c=Color.RED; 
</code>
而且这些枚举值都是public static final的，也就是我们经常所定义的常量方式，因此枚举类中的枚举值最好全部大写。

2、即然枚举类是class，当然在枚举类型中有构造器，方法和数据域。但是，枚举类的构造器有很大的不同：
(1) 构造器只是在构造枚举值的时候被调用。
<code lang="java">  
enum Color{  
  // 枚举列表必须写在最前面，否则编译出错
   RED(255,0,0),BLUE(0,0,255),BLACK(0,0,0),YELLOW(255,255,0),GREEN(0,255,0);  
  //赋值必须是都赋值或都不赋值，不能一部分赋值一部分不赋值，如果不赋值则不能写构造器，赋值编译也出错
  //这里private也可以不用写，因为构造器默认是private, 从而保证构造函数只能在内部使用
  private Color(int rv,int gv,int bv){  
    this.redValue=rv;  
    this.greenValue=gv;  
    this.blueValue=bv;  
  }  
  
  public String toString(){  //自定义的public方法  
    return super.toString()+"("+redValue+","+greenValue+","+blueValue+")";  
  }  
     
  private int redValue;  //自定义数据域，private为了封装。  
    private int greenValue;  
    private int blueValue;  
 } 
</code> ]]></description>
				<content:encoded><![CDATA[<p>枚举类型是JDK5.0的新特征。下面就是一个典型枚举类型的定义：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">enum</span> <span style="color: #003399;">Color</span><span style="color: #009900;">&#123;</span>  
    RED,BLUE,BLACK,YELLOW,GREEN  
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>显然，enum很像特殊的class，实际上enum声明定义的类型就是一个类。而这些类都是类库中Enum类的子类(java.lang.Enum<e>)。它们<strong>继承</strong>了这个Enum中的许多有用的方法。在Color.java中编写此段代码并编译，虽然语法上不像是在定义类，但枚举类型本质上就是一个类。所以编译完成后，会产生一个Color.class文件。</p>
<p>下面我们就详细介绍enum定义的枚举类的特征及其用法。</p>
<p>1、Color枚举类是特殊的class，其枚举值(RED,BLUE&#8230;)是Color的类对象(类实例)：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #003399;">Color</span> c<span style="color: #339933;">=</span><span style="color: #003399;">Color</span>.<span style="color: #006633;">RED</span><span style="color: #339933;">;</span></pre></div></div>

<p>而且这些枚举值都是public static final的，也就是我们经常所定义的常量方式，因此枚举类中的枚举值最好全部大写。</p>
<p>2、即然枚举类是class，当然在枚举类型中有构造器，方法和数据域。但是，枚举类的构造器有很大的不同：<br />
(1) 构造器只是在构造枚举值的时候被调用。</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">enum</span> <span style="color: #003399;">Color</span><span style="color: #009900;">&#123;</span>  
  <span style="color: #666666; font-style: italic;">// 枚举列表必须写在最前面，否则编译出错</span>
   RED<span style="color: #009900;">&#40;</span><span style="color: #cc66cc;">255</span>,<span style="color: #cc66cc;">0</span>,<span style="color: #cc66cc;">0</span><span style="color: #009900;">&#41;</span>,BLUE<span style="color: #009900;">&#40;</span><span style="color: #cc66cc;">0</span>,<span style="color: #cc66cc;">0</span>,<span style="color: #cc66cc;">255</span><span style="color: #009900;">&#41;</span>,BLACK<span style="color: #009900;">&#40;</span><span style="color: #cc66cc;">0</span>,<span style="color: #cc66cc;">0</span>,<span style="color: #cc66cc;">0</span><span style="color: #009900;">&#41;</span>,YELLOW<span style="color: #009900;">&#40;</span><span style="color: #cc66cc;">255</span>,<span style="color: #cc66cc;">255</span>,<span style="color: #cc66cc;">0</span><span style="color: #009900;">&#41;</span>,GREEN<span style="color: #009900;">&#40;</span><span style="color: #cc66cc;">0</span>,<span style="color: #cc66cc;">255</span>,<span style="color: #cc66cc;">0</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
  <span style="color: #666666; font-style: italic;">//赋值必须是都赋值或都不赋值，不能一部分赋值一部分不赋值，如果不赋值则不能写构造器，赋值编译也出错</span>
  <span style="color: #666666; font-style: italic;">//这里private也可以不用写，因为构造器默认是private, 从而保证构造函数只能在内部使用</span>
  <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #003399;">Color</span><span style="color: #009900;">&#40;</span><span style="color: #000066; font-weight: bold;">int</span> rv,<span style="color: #000066; font-weight: bold;">int</span> gv,<span style="color: #000066; font-weight: bold;">int</span> bv<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>  
    <span style="color: #000000; font-weight: bold;">this</span>.<span style="color: #006633;">redValue</span><span style="color: #339933;">=</span>rv<span style="color: #339933;">;</span>  
    <span style="color: #000000; font-weight: bold;">this</span>.<span style="color: #006633;">greenValue</span><span style="color: #339933;">=</span>gv<span style="color: #339933;">;</span>  
    <span style="color: #000000; font-weight: bold;">this</span>.<span style="color: #006633;">blueValue</span><span style="color: #339933;">=</span>bv<span style="color: #339933;">;</span>  
  <span style="color: #009900;">&#125;</span>  
&nbsp;
  <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #003399;">String</span> toString<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>  <span style="color: #666666; font-style: italic;">//自定义的public方法  </span>
    <span style="color: #000000; font-weight: bold;">return</span> <span style="color: #000000; font-weight: bold;">super</span>.<span style="color: #006633;">toString</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">+</span><span style="color: #0000ff;">&quot;(&quot;</span><span style="color: #339933;">+</span>redValue<span style="color: #339933;">+</span><span style="color: #0000ff;">&quot;,&quot;</span><span style="color: #339933;">+</span>greenValue<span style="color: #339933;">+</span><span style="color: #0000ff;">&quot;,&quot;</span><span style="color: #339933;">+</span>blueValue<span style="color: #339933;">+</span><span style="color: #0000ff;">&quot;)&quot;</span><span style="color: #339933;">;</span>  
  <span style="color: #009900;">&#125;</span>  
&nbsp;
  <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000066; font-weight: bold;">int</span> redValue<span style="color: #339933;">;</span>  <span style="color: #666666; font-style: italic;">//自定义数据域，private为了封装。  </span>
    <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000066; font-weight: bold;">int</span> greenValue<span style="color: #339933;">;</span>  
    <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000066; font-weight: bold;">int</span> blueValue<span style="color: #339933;">;</span>  
 <span style="color: #009900;">&#125;</span></pre></div></div>

]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7511.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java类的生存周期</title>
		<link>http://www.xieziming.com/archives/7508.html</link>
		<comments>http://www.xieziming.com/archives/7508.html#respond</comments>
		<pubDate>Thu, 11 Oct 2012 14:44:51 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7508</guid>
		<description><![CDATA[首先来了解一下jvm（java虚拟机）中的几个比较重要的内存区域，这几个区域在java类的生命周期中扮演着比较重要的角色：

<strong>方法区：</strong>在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。

<strong>常量池：</strong>常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。
<strong>堆区：</strong>用于存放类的对象实例。
<strong>栈区：</strong>也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。

除了以上四个内存区域之外，jvm中的运行时内存区域还包括本地方法栈和程序计数器，这两个区域与java类的生命周期关系不是很大，在这里就不说了。

类的成员变量有两种：一种是被static关键字修饰的变量，叫类变量或静态变量，一种是没有被static修饰的，叫做实例变量。

静态变量和实例变量的区别在于：

类静态变量在内存中只有一个，java虚拟机在加载类的过程中为静态变量分配内存，静态变量位于方法区，被类的所有实例共享，静态变量可以通过类名直接访问。静态变量的生命周期取决于类的生命周期，当类被加载的时候，静态变量被创建并分配内存空间，当类被卸载时，静态变量被摧毁，并释放所占有的内存。

类的每一个实例都有相应的实例变量，每创建一个类的实例，java虚拟机为实例变量分配一次内存，实例变量位于堆区中，实例变量的生命周期取决于实例的生命周期，当创建实例时，实例变量同时被创建，并分配内存，当实例被销毁时，实例变量被销毁，并释放所占有的内存空间。

变量的生命周期和对象的生命周期是不同的概念。成员变量结束生命周期时，并不意味着它所引用对象也结束生命周期。]]></description>
				<content:encoded><![CDATA[<p>首先来了解一下jvm（java虚拟机）中的几个比较重要的内存区域，这几个区域在java类的生命周期中扮演着比较重要的角色：</p>
<p><strong>方法区：</strong>在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。</p>
<p><strong>常量池：</strong>常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。<br />
<strong>堆区：</strong>用于存放类的对象实例。<br />
<strong>栈区：</strong>也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。</p>
<p>除了以上四个内存区域之外，jvm中的运行时内存区域还包括本地方法栈和程序计数器，这两个区域与java类的生命周期关系不是很大，在这里就不说了。</p>
<p>类的成员变量有两种：一种是被static关键字修饰的变量，叫类变量或静态变量，一种是没有被static修饰的，叫做实例变量。</p>
<p>静态变量和实例变量的区别在于：</p>
<p>类静态变量在内存中只有一个，java虚拟机在加载类的过程中为静态变量分配内存，静态变量位于方法区，被类的所有实例共享，静态变量可以通过类名直接访问。静态变量的生命周期取决于类的生命周期，当类被加载的时候，静态变量被创建并分配内存空间，当类被卸载时，静态变量被摧毁，并释放所占有的内存。</p>
<p>类的每一个实例都有相应的实例变量，每创建一个类的实例，java虚拟机为实例变量分配一次内存，实例变量位于堆区中，实例变量的生命周期取决于实例的生命周期，当创建实例时，实例变量同时被创建，并分配内存，当实例被销毁时，实例变量被销毁，并释放所占有的内存空间。</p>
<p>变量的生命周期和对象的生命周期是不同的概念。成员变量结束生命周期时，并不意味着它所引用对象也结束生命周期。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7508.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java代理机制</title>
		<link>http://www.xieziming.com/archives/7499.html</link>
		<comments>http://www.xieziming.com/archives/7499.html#respond</comments>
		<pubDate>Wed, 10 Oct 2012 17:42:25 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7499</guid>
		<description><![CDATA[代理模式的作用是：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 

代理模式一般涉及到的角色有： 

<strong>抽象角色：</strong>声明真实对象和代理对象的共同接口； 

<strong>代理角色：</strong>代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 

<strong>真实角色：</strong>代理角色所代表的真实对象，是我们最终要引用的对象。

抽象角色： 
<code lang="java">
interface Subject { 
  public void request(); 
}  
</code>
真实角色：实现了Subject的request()方法。 
<code lang="java">
public class RealSubject implements Subject { 
  public RealSubject() { } 
  public void request() { 
   System.out.println("From real subject."); 
  } 
} 
</code>]]></description>
				<content:encoded><![CDATA[<p>代理模式的作用是：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 </p>
<p>代理模式一般涉及到的角色有： </p>
<p><strong>抽象角色：</strong>声明真实对象和代理对象的共同接口； </p>
<p><strong>代理角色：</strong>代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 </p>
<p><strong>真实角色：</strong>代理角色所代表的真实对象，是我们最终要引用的对象。</p>
<p>抽象角色：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">interface</span> Subject <span style="color: #009900;">&#123;</span> 
  <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">void</span> request<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>真实角色：实现了Subject的request()方法。</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> RealSubject <span style="color: #000000; font-weight: bold;">implements</span> Subject <span style="color: #009900;">&#123;</span> 
  <span style="color: #000000; font-weight: bold;">public</span> RealSubject<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> <span style="color: #009900;">&#125;</span> 
  <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">void</span> request<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> 
   <span style="color: #003399;">System</span>.<span style="color: #006633;">out</span>.<span style="color: #006633;">println</span><span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;From real subject.&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 
  <span style="color: #009900;">&#125;</span> 
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>代理角色：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> ProxySubject <span style="color: #000000; font-weight: bold;">extends</span> Subject <span style="color: #009900;">&#123;</span> 
  <span style="color: #000000; font-weight: bold;">private</span> RealSubject realSubject<span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">//以真实角色作为代理角色的属性 </span>
  <span style="color: #000000; font-weight: bold;">public</span> ProxySubject<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> <span style="color: #009900;">&#125;</span> 
  <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">void</span> request<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span> <span style="color: #666666; font-style: italic;">//该方法封装了真实对象的request方法 </span>
    preRequest<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 
    <span style="color: #000000; font-weight: bold;">if</span><span style="color: #009900;">&#40;</span> realSubject <span style="color: #339933;">==</span> <span style="color: #000066; font-weight: bold;">null</span> <span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> 
       realSubject <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> RealSubject<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 
    <span style="color: #009900;">&#125;</span> 
    realSubject.<span style="color: #006633;">request</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">//此处执行真实对象的request方法 </span>
    postRequest<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 
  <span style="color: #009900;">&#125;</span> 
&nbsp;
  <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000066; font-weight: bold;">void</span> preRequest<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> 
    <span style="color: #666666; font-style: italic;">//something you want to do before requesting </span>
  <span style="color: #009900;">&#125;</span> 
  <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000066; font-weight: bold;">void</span> postRequest<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> 
    <span style="color: #666666; font-style: italic;">//something you want to do after requesting </span>
  <span style="color: #009900;">&#125;</span> 
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>客户端调用：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;">Subject sub<span style="color: #339933;">=</span><span style="color: #000000; font-weight: bold;">new</span> ProxySubject<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 
Sub.<span style="color: #006633;">request</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span></pre></div></div>

<p>由以上代码可以看出，客户实际需要调用的是RealSubject类的request()方法，现在用ProxySubject来代理 RealSubject类，同样达到目的，同时还封装了其他方法(preRequest(),postRequest())，可以处理一些其他问题。 </p>
<p>另外，如果要按照上述的方法使用代理模式，那么真实角色必须是事先已经存在的，并将其作为代理对象的内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，如果大量使用会导致类的急剧膨胀；此外，如果事先并不知道真实角色，该如何使用代理呢？这个问题可以通过Java的动态代理类来解决。 </p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7499.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java反射机制</title>
		<link>http://www.xieziming.com/archives/7496.html</link>
		<comments>http://www.xieziming.com/archives/7496.html#respond</comments>
		<pubDate>Wed, 10 Oct 2012 16:19:01 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7496</guid>
		<description><![CDATA[JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法。


【案例1】通过一个对象获得完整的包名和类名
<code lang="java">
package Reflect; 
/**
 * 通过一个对象获得完整的包名和类名
 * */
class Demo{
    //other codes...
}
 
class hello{
    public static void main(String[] args) {
        Demo demo=new Demo();
        System.out.println(demo.getClass().getName());
    }
}
</code>
【运行结果】：Reflect.Demo]]></description>
				<content:encoded><![CDATA[<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法。</p>
<p>【案例1】通过一个对象获得完整的包名和类名</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">package</span> <span style="color: #006699;">Reflect</span><span style="color: #339933;">;</span> 
<span style="color: #008000; font-style: italic; font-weight: bold;">/**
 * 通过一个对象获得完整的包名和类名
 * */</span>
<span style="color: #000000; font-weight: bold;">class</span> Demo<span style="color: #009900;">&#123;</span>
    <span style="color: #666666; font-style: italic;">//other codes...</span>
<span style="color: #009900;">&#125;</span>
&nbsp;
<span style="color: #000000; font-weight: bold;">class</span> hello<span style="color: #009900;">&#123;</span>
    <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">static</span> <span style="color: #000066; font-weight: bold;">void</span> main<span style="color: #009900;">&#40;</span><span style="color: #003399;">String</span><span style="color: #009900;">&#91;</span><span style="color: #009900;">&#93;</span> args<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
        Demo demo<span style="color: #339933;">=</span><span style="color: #000000; font-weight: bold;">new</span> Demo<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
        <span style="color: #003399;">System</span>.<span style="color: #006633;">out</span>.<span style="color: #006633;">println</span><span style="color: #009900;">&#40;</span>demo.<span style="color: #006633;">getClass</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span>.<span style="color: #006633;">getName</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
    <span style="color: #009900;">&#125;</span>
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>【运行结果】：Reflect.Demo</p>
<p>【案例2】实例化Class类对象</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">package</span> <span style="color: #006699;">Reflect</span><span style="color: #339933;">;</span>
<span style="color: #000000; font-weight: bold;">class</span> Demo<span style="color: #009900;">&#123;</span>
    <span style="color: #666666; font-style: italic;">//other codes...</span>
<span style="color: #009900;">&#125;</span>
&nbsp;
<span style="color: #000000; font-weight: bold;">class</span> hello<span style="color: #009900;">&#123;</span>
    <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">static</span> <span style="color: #000066; font-weight: bold;">void</span> main<span style="color: #009900;">&#40;</span><span style="color: #003399;">String</span><span style="color: #009900;">&#91;</span><span style="color: #009900;">&#93;</span> args<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
        Class<span style="color: #339933;">&lt;</span> <span style="color: #339933;">?&gt;</span> demo1<span style="color: #339933;">=</span><span style="color: #000066; font-weight: bold;">null</span><span style="color: #339933;">;</span>
        Class<span style="color: #339933;">&lt;</span> <span style="color: #339933;">?&gt;</span> demo2<span style="color: #339933;">=</span><span style="color: #000066; font-weight: bold;">null</span><span style="color: #339933;">;</span>
        Class<span style="color: #339933;">&lt;</span> <span style="color: #339933;">?&gt;</span> demo3<span style="color: #339933;">=</span><span style="color: #000066; font-weight: bold;">null</span><span style="color: #339933;">;</span>
        <span style="color: #000000; font-weight: bold;">try</span><span style="color: #009900;">&#123;</span>
            <span style="color: #666666; font-style: italic;">//一般尽量采用这种形式</span>
            demo1<span style="color: #339933;">=</span><span style="color: #000000; font-weight: bold;">Class</span>.<span style="color: #006633;">forName</span><span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;Reflect.Demo&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
        <span style="color: #009900;">&#125;</span><span style="color: #000000; font-weight: bold;">catch</span><span style="color: #009900;">&#40;</span><span style="color: #003399;">Exception</span> e<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#123;</span>
            e.<span style="color: #006633;">printStackTrace</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
        <span style="color: #009900;">&#125;</span>
        demo2<span style="color: #339933;">=</span><span style="color: #000000; font-weight: bold;">new</span> Demo<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span>.<span style="color: #006633;">getClass</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
        demo3<span style="color: #339933;">=</span>Demo.<span style="color: #000000; font-weight: bold;">class</span><span style="color: #339933;">;</span>
&nbsp;
        <span style="color: #003399;">System</span>.<span style="color: #006633;">out</span>.<span style="color: #006633;">println</span><span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;类名称   &quot;</span><span style="color: #339933;">+</span>demo1.<span style="color: #006633;">getName</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
        <span style="color: #003399;">System</span>.<span style="color: #006633;">out</span>.<span style="color: #006633;">println</span><span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;类名称   &quot;</span><span style="color: #339933;">+</span>demo2.<span style="color: #006633;">getName</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
        <span style="color: #003399;">System</span>.<span style="color: #006633;">out</span>.<span style="color: #006633;">println</span><span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;类名称   &quot;</span><span style="color: #339933;">+</span>demo3.<span style="color: #006633;">getName</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&nbsp;
    <span style="color: #009900;">&#125;</span>
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>【运行结果】：<br />
类名称   Reflect.Demo<br />
类名称   Reflect.Demo<br />
类名称   Reflect.Demo</p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7496.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java堆栈</title>
		<link>http://www.xieziming.com/archives/7486.html</link>
		<comments>http://www.xieziming.com/archives/7486.html#respond</comments>
		<pubDate>Tue, 09 Oct 2012 15:47:22 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7486</guid>
		<description><![CDATA[Java中每个方法被执行的时候都会同时创建一个栈帧（stack frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。

局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。

Java把内存划分成两种：一种是栈内存，一种是堆内存。栈中存放是局部变量，堆中存放的是实例变量和对象(数组也是对象类型)。

栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：
<code lang="java">
int a = 3; 
int b = 3； 
</code>
编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，假如没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，假如再令a=4；那么编译器 会重新搜索栈中是否有4值，假如没有，则将4存放进来，并令a指向4；假如已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要留意这 种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，由于这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。 

String是一个特殊的包装类数据。可以用： 
<code lang="java">
String str = new String("abc"); 
String str = "abc"; 
</code>
两种的形式来创建，第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。而第二种是先在栈中创建一个对String类的对象引用变量str，然后查找栈中有没有存放"abc"，假如没有，则将"abc"存放进栈，并令str指向”abc”，假如已经有”abc” 则直接令str指向“abc”。 ]]></description>
				<content:encoded><![CDATA[<p>Java中每个方法被执行的时候都会同时创建一个栈帧（stack frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。</p>
<p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>
<p>Java把内存划分成两种：一种是栈内存，一种是堆内存。栈中存放是局部变量，堆中存放的是实例变量和对象(数组也是对象类型)。</p>
<p>栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000066; font-weight: bold;">int</span> a <span style="color: #339933;">=</span> <span style="color: #cc66cc;">3</span><span style="color: #339933;">;</span> 
<span style="color: #000066; font-weight: bold;">int</span> b <span style="color: #339933;">=</span> <span style="color: #cc66cc;">3</span>；</pre></div></div>

<p>编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，假如没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，假如再令a=4；那么编译器 会重新搜索栈中是否有4值，假如没有，则将4存放进来，并令a指向4；假如已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要留意这 种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，由于这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。 </p>
<p>String是一个特殊的包装类数据。可以用：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #003399;">String</span> str <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> <span style="color: #003399;">String</span><span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;abc&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 
<span style="color: #003399;">String</span> str <span style="color: #339933;">=</span> <span style="color: #0000ff;">&quot;abc&quot;</span><span style="color: #339933;">;</span></pre></div></div>

<p>两种的形式来创建，第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。而第二种是先在栈中创建一个对String类的对象引用变量str，然后查找栈中有没有存放&#8221;abc&#8221;，假如没有，则将&#8221;abc&#8221;存放进栈，并令str指向”abc”，假如已经有”abc” 则直接令str指向“abc”。 </p>
<p>比较类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==，下面用例子说明上面的理论。</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #003399;">String</span> str1 <span style="color: #339933;">=</span> <span style="color: #0000ff;">&quot;abc&quot;</span><span style="color: #339933;">;</span> 
<span style="color: #003399;">String</span> str2 <span style="color: #339933;">=</span> <span style="color: #0000ff;">&quot;abc&quot;</span><span style="color: #339933;">;</span> 
<span style="color: #003399;">System</span>.<span style="color: #006633;">out</span>.<span style="color: #006633;">println</span><span style="color: #009900;">&#40;</span>str1<span style="color: #339933;">==</span>str2<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">//true</span></pre></div></div>

<p>可以看出str1和str2是指向同一个对象的。</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #003399;">String</span> str1 <span style="color: #339933;">=</span><span style="color: #000000; font-weight: bold;">new</span> <span style="color: #003399;">String</span> <span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;abc&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 
<span style="color: #003399;">String</span> str2 <span style="color: #339933;">=</span><span style="color: #000000; font-weight: bold;">new</span> <span style="color: #003399;">String</span> <span style="color: #009900;">&#40;</span><span style="color: #0000ff;">&quot;abc&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 
<span style="color: #003399;">System</span>.<span style="color: #006633;">out</span>.<span style="color: #006633;">println</span><span style="color: #009900;">&#40;</span>str1<span style="color: #339933;">==</span>str2<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> <span style="color: #666666; font-style: italic;">// false</span></pre></div></div>

<p>用new的方式是天生不同的对象。每一次产生一个。 </p>
<p>因此用第二种方式创建多个”abc”字符串,在内存中实在只存在一个对象而已. 这种写法有利与节省内存空间. 同时它可以在一定程度上进步程序的运行速度，由于JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。</p>
<p>而对于String str = new String(&#8220;abc&#8221;)；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。 </p>
<p>另一方面, 要留意: 我们在使用诸如String str = &#8220;abc&#8221;；的格式定义类时，总是想当然地以为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的对象。只有通过new()方法才能保证每次都创建一个新的对象。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7486.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java单例模式</title>
		<link>http://www.xieziming.com/archives/7481.html</link>
		<comments>http://www.xieziming.com/archives/7481.html#respond</comments>
		<pubDate>Mon, 08 Oct 2012 16:05:11 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7481</guid>
		<description><![CDATA[单例模式的主要目的是希望对象只创建一个实例，并且提供一个全局的访问点。
<code lang="java"> 
public class SingletonKerriganA {  
    private static SingletonKerriganA instance = null;  
   
    public static SingletonKerriganA getInstance() {  
        if (instance == null) {                              
            instance = new SingletonKerriganA(); 
        }  
        return instance;  
    }  
} 
</code>
这个写法我们把四点需求从上往下检测，发现第二点的时候就出了问题，假设这样的场景：两个线程并发调用SingletonKerriganA.getInstance()，假设线程一先判断完instance是否为null，既代码中的line A进入到line B的位置。刚刚判断完毕后，JVM将CPU资源切换给线程二，由于线程一还没执行line B，所以instance仍然是空的，因此线程二执行了new SignletonKerriganA()操作。片刻之后，线程一被重新唤醒，它执行的仍然是new SignletonKerriganA()操作，好了，问题来了，两个Kerrigan谁是李逵谁是李鬼？]]></description>
				<content:encoded><![CDATA[<p>单例模式的主要目的是希望对象只创建一个实例，并且提供一个全局的访问点。</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> SingletonKerriganA <span style="color: #009900;">&#123;</span>  
    <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000000; font-weight: bold;">static</span> SingletonKerriganA instance <span style="color: #339933;">=</span> <span style="color: #000066; font-weight: bold;">null</span><span style="color: #339933;">;</span>  
&nbsp;
    <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">static</span> SingletonKerriganA getInstance<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
        <span style="color: #000000; font-weight: bold;">if</span> <span style="color: #009900;">&#40;</span>instance <span style="color: #339933;">==</span> <span style="color: #000066; font-weight: bold;">null</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>                              
            instance <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> SingletonKerriganA<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 
        <span style="color: #009900;">&#125;</span>  
        <span style="color: #000000; font-weight: bold;">return</span> instance<span style="color: #339933;">;</span>  
    <span style="color: #009900;">&#125;</span>  
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>假设这样的场景：两个线程并发调用SingletonKerriganA.getInstance()，假设线程一先判断完instance是否为null，既代码中的line A进入到line B的位置。刚刚判断完毕后，JVM将CPU资源切换给线程二，由于线程一还没执行line B，所以instance仍然是空的，因此线程二执行了new SignletonKerriganA()操作。片刻之后，线程一被重新唤醒，它执行的仍然是new SignletonKerriganA()操作，好了，问题来了，两个Kerrigan谁是李逵谁是李鬼？</p>
<p>紧接着，我们做单例模式的第二次尝试：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> SingletonKerriganB <span style="color: #009900;">&#123;</span>   
    <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000000; font-weight: bold;">static</span> SingletonKerriganB instance <span style="color: #339933;">=</span> <span style="color: #000066; font-weight: bold;">null</span><span style="color: #339933;">;</span>  
&nbsp;
    <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">synchronized</span> <span style="color: #000000; font-weight: bold;">static</span> SingletonKerriganB getInstance<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
        <span style="color: #000000; font-weight: bold;">if</span> <span style="color: #009900;">&#40;</span>instance <span style="color: #339933;">==</span> <span style="color: #000066; font-weight: bold;">null</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
            instance <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> SingletonKerriganB<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
        <span style="color: #009900;">&#125;</span>  
        <span style="color: #000000; font-weight: bold;">return</span> instance<span style="color: #339933;">;</span>  
    <span style="color: #009900;">&#125;</span>  
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>比起第一段代码仅仅在方法中多了一个synchronized修饰符，现在可以保证不会出线程问题了。但是这里有个很大（至少耗时比例上很大）的性能问题。除了第一次调用时是执行了SingletonKerriganB的构造函数之外，以后的每一次调用都是直接返回instance对象。返回对象这个操作耗时是很小的，绝大部分的耗时都用在synchronized修饰符的同步准备上，因此从性能上说很不划算。</p>
<p>那继续把代码改成下面的样子：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> SingletonKerriganC <span style="color: #009900;">&#123;</span>  
    <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000000; font-weight: bold;">static</span> SingletonKerriganC instance <span style="color: #339933;">=</span> <span style="color: #000066; font-weight: bold;">null</span><span style="color: #339933;">;</span>  
&nbsp;
    <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">static</span> SingletonKerriganC getInstance<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
        <span style="color: #000000; font-weight: bold;">synchronized</span> <span style="color: #009900;">&#40;</span>SingletonKerriganC.<span style="color: #000000; font-weight: bold;">class</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
            <span style="color: #000000; font-weight: bold;">if</span> <span style="color: #009900;">&#40;</span>instance <span style="color: #339933;">==</span> <span style="color: #000066; font-weight: bold;">null</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
                instance <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> SingletonKerriganC<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
            <span style="color: #009900;">&#125;</span>  
        <span style="color: #009900;">&#125;</span>  
        <span style="color: #000000; font-weight: bold;">return</span> instance<span style="color: #339933;">;</span>  
    <span style="color: #009900;">&#125;</span>  
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>基本上，把synchronized移动到代码内部是没有什么意义的，每次调用getInstance()还是要进行同步。同步本身没有问题，但是我们只希望在第一次创建Kerrigan实例的时候进行同步，因此我们有了下面的写法——双重锁定检查（DCL）。</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> SingletonKerriganD <span style="color: #009900;">&#123;</span>   
    <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000000; font-weight: bold;">static</span> SingletonKerriganD instance <span style="color: #339933;">=</span> <span style="color: #000066; font-weight: bold;">null</span><span style="color: #339933;">;</span>  
&nbsp;
    <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">static</span> SingletonKerriganD getInstance<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
        <span style="color: #000000; font-weight: bold;">if</span> <span style="color: #009900;">&#40;</span>instance <span style="color: #339933;">==</span> <span style="color: #000066; font-weight: bold;">null</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
            <span style="color: #000000; font-weight: bold;">synchronized</span> <span style="color: #009900;">&#40;</span>SingletonKerriganD.<span style="color: #000000; font-weight: bold;">class</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
                <span style="color: #000000; font-weight: bold;">if</span> <span style="color: #009900;">&#40;</span>instance <span style="color: #339933;">==</span> <span style="color: #000066; font-weight: bold;">null</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
                    instance <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> SingletonKerriganD<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
                <span style="color: #009900;">&#125;</span>  
            <span style="color: #009900;">&#125;</span>  
        <span style="color: #009900;">&#125;</span>  
        <span style="color: #000000; font-weight: bold;">return</span> instance<span style="color: #339933;">;</span>  
    <span style="color: #009900;">&#125;</span>  
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>看起来这样已经达到了我们的要求，除了第一次创建对象之外，其他的访问在第一个if中就返回了，因此不会走到同步块中。已经完美了吗？</p>
<p>我们来看看这个场景：假设线程一执行到instance = new SingletonKerriganD()这句，这里看起来是一句话，但实际上它并不是一个原子操作（原子操作的意思就是这条语句要么就被执行完，要么就没有被执行过，不能出现执行了一半这种情形）。事实上高级语言里面非原子操作有很多，我们只要看看这句话被编译后在JVM执行的对应汇编代码就发现，这句话被编译成8条汇编指令，大致做了3件事情：</p>
<p>1.给Kerrigan的实例分配内存。<br />
2.初始化Kerrigan的构造器<br />
3.将instance对象指向分配的内存空间（注意到这步instance就非null了）。</p>
<p>但是，由于Java编译器允许处理器乱序执行（out-of-order），以及JDK1.5之前JMM（Java Memory Medel）中Cache、寄存器到主内存回写顺序的规定，上面的第二点和第三点的顺序是无法保证的，也就是说，执行顺序可能是1-2-3也可能是1-3-2，如果是后者，并且在3执行完毕、2未执行之前，被切换到线程二上，这时候instance因为已经在线程一内执行过了第三点，instance已经是非空了，所以线程二直接拿走instance，然后使用，然后顺理成章地报错，而且这种难以跟踪难以重现的错误估计调试上一星期都未必能找得出来，真是一茶几的杯具啊。</p>
<p>代码倒越来越复杂了，现在先来个返璞归真，根据JLS（Java Language Specification）中的规定，一个类在一个ClassLoader中只会被初始化一次，这点是JVM本身保证的，那就把初始化实例的事情扔给JVM好了，代码被改成这样：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> SingletonKerriganE <span style="color: #009900;">&#123;</span>  
    <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000000; font-weight: bold;">static</span> SingletonKerriganE instance <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> SingletonKerriganE<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
&nbsp;
    <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">static</span> SingletonKerriganE getInstance<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
        <span style="color: #000000; font-weight: bold;">return</span> instance<span style="color: #339933;">;</span>  
    <span style="color: #009900;">&#125;</span>  
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>好吧，如果这种写法是完美的话，那前面那么几大段话就是作者在消遣各位读者。这种写法不会出现并发问题，但是它是饿汉式的，在ClassLoader加载类后Kerrigan的实例就会第一时间被创建，饿汉式的创建方式在一些场景中将无法使用：譬如Kerrigan实例的创建是依赖参数或者配置文件的，在getInstance()之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> SingletonKerriganF <span style="color: #009900;">&#123;</span>    
    <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000000; font-weight: bold;">static</span> <span style="color: #000000; font-weight: bold;">class</span> SingletonHolder <span style="color: #009900;">&#123;</span>  
        <span style="color: #000000; font-weight: bold;">static</span> <span style="color: #000000; font-weight: bold;">final</span> SingletonKerriganF INSTANCE <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> SingletonKerriganF<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
    <span style="color: #009900;">&#125;</span>  
&nbsp;
    <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">static</span> SingletonKerriganF getInstance<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
        <span style="color: #000000; font-weight: bold;">return</span> SingletonHolder.<span style="color: #006633;">INSTANCE</span><span style="color: #339933;">;</span>  
    <span style="color: #009900;">&#125;</span>  
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于SingletonHolder是私有的，除了getInstance()之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖JDK版本。</p>
<p>一般我们会加入一个private或者protected的构造函数，这样系统就不会自动添加那个public的构造函数了，因此只能调用里面的static方法，无法通过new创建对象。</p>
<p>如果单例对象有必要实现Serializable接口（很少出现），则应当同时实现readResolve()方法来保证反序列化的时候得到原来的对象。</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> SingletonKerrigan <span style="color: #000000; font-weight: bold;">implements</span> <span style="color: #003399;">Serializable</span> <span style="color: #009900;">&#123;</span>     
    <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000000; font-weight: bold;">static</span> <span style="color: #000000; font-weight: bold;">class</span> SingletonHolder <span style="color: #009900;">&#123;</span>  
        <span style="color: #000000; font-weight: bold;">static</span> <span style="color: #000000; font-weight: bold;">final</span> SingletonKerrigan INSTANCE <span style="color: #339933;">=</span> <span style="color: #000000; font-weight: bold;">new</span> SingletonKerrigan<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
    <span style="color: #009900;">&#125;</span>  
&nbsp;
    <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">static</span> SingletonKerrigan getInstance<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
        <span style="color: #000000; font-weight: bold;">return</span> SingletonHolder.<span style="color: #006633;">INSTANCE</span><span style="color: #339933;">;</span>  
    <span style="color: #009900;">&#125;</span>  
&nbsp;
    <span style="color: #008000; font-style: italic; font-weight: bold;">/** 
     * private的构造函数用于避免外界直接使用new来实例化对象 
     */</span>  
    <span style="color: #000000; font-weight: bold;">private</span> SingletonKerrigan<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
    <span style="color: #009900;">&#125;</span>  
&nbsp;
    <span style="color: #008000; font-style: italic; font-weight: bold;">/** 
     * readResolve方法应对单例对象被序列化时候 
     */</span>  
    <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #003399;">Object</span> readResolve<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>  
        <span style="color: #000000; font-weight: bold;">return</span> getInstance<span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>  
    <span style="color: #009900;">&#125;</span>  
<span style="color: #009900;">&#125;</span></pre></div></div>

]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7481.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java静态工厂模式</title>
		<link>http://www.xieziming.com/archives/7473.html</link>
		<comments>http://www.xieziming.com/archives/7473.html#respond</comments>
		<pubDate>Mon, 08 Oct 2012 14:50:10 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7473</guid>
		<description><![CDATA[创建类的实例的最常见的方式是用new语句调用类的构造方法。在这种情况下，程序可以创建类的任意多个实例，每执行一条new语句，都会导致Java虚拟机的堆区中产生一个新的对象。假如类需要进一步封装创建自身实例的细节，并且控制自身实例的数目，那么可以提供静态工厂方法。
       
所谓的工厂是提供一个特定的类，这个类是专门用来创建对象实例，客户端无须关心具体的实现。这个模式由三个部分组成。

<strong>抽象类：</strong>它对外提供方法的调用，屏蔽了内部具体的实现。

<strong>具体实现类：</strong>相同类的不同实体的具体实现，一般情况下它包含多个实现类。

<strong>工厂类：</strong>它提供一个统一的生成具体对象的方法，在这个方法中会有一些逻辑的判断，根据参数的不同来创建不同的实例。一般情况下，这个工厂类定义成为了static的类型，所以也称为静态工厂模式。

<strong>优点：</strong>

(1) 构造函数有命名的限制，而静态方法有自己的名字，更加易于理解。

(2) 静态工厂方法在每次调用的时候不要求创建一个新的对象。这种做法对于一个要频繁创建相同对象的程序来说，可以极大的提高性能。它使得一个类可以保证是一个singleton；他使非可变类可以保证“不会有两个相等的实例存在”。

(3) 静态工厂方法在选择返回类型时有更大的灵活性。使用静态工厂方法，可以通过调用方法时使用不同的参数创建不同类的实例，还可以创建非公有类的对象，这就封装了类的实现细节。]]></description>
				<content:encoded><![CDATA[<p>创建类的实例的最常见的方式是用new语句调用类的构造方法。在这种情况下，程序可以创建类的任意多个实例，每执行一条new语句，都会导致Java虚拟机的堆区中产生一个新的对象。假如类需要进一步封装创建自身实例的细节，并且控制自身实例的数目，那么可以提供静态工厂方法。</p>
<p>所谓的工厂是提供一个特定的类，这个类是专门用来创建对象实例，客户端无须关心具体的实现。这个模式由三个部分组成。</p>
<p><strong>抽象类：</strong>它对外提供方法的调用，屏蔽了内部具体的实现。</p>
<p><strong>具体实现类：</strong>相同类的不同实体的具体实现，一般情况下它包含多个实现类。</p>
<p><strong>工厂类：</strong>它提供一个统一的生成具体对象的方法，在这个方法中会有一些逻辑的判断，根据参数的不同来创建不同的实例。一般情况下，这个工厂类定义成为了static的类型，所以也称为静态工厂模式。</p>
<p><strong>优点：</strong></p>
<p>(1) 构造函数有命名的限制，而静态方法有自己的名字，更加易于理解。</p>
<p>(2) 静态工厂方法在每次调用的时候不要求创建一个新的对象。这种做法对于一个要频繁创建相同对象的程序来说，可以极大的提高性能。它使得一个类可以保证是一个singleton；他使非可变类可以保证“不会有两个相等的实例存在”。</p>
<p>(3) 静态工厂方法在选择返回类型时有更大的灵活性。使用静态工厂方法，可以通过调用方法时使用不同的参数创建不同类的实例，还可以创建非公有类的对象，这就封装了类的实现细节。</p>
<p><strong>缺点：</strong></p>
<p>(1) 如果一个类是通过静态工厂方法来取得实例的，并且该类的构造函数都不是公有的或者保护的，那该类就不可能有子类（被继承），子类的构造函数需要首先调用父类的构造函数，因为父类的构造函数是private的,所以即使我们假设继承成功的话,那么子类也根本没有权限去调用父类的私有构造函数，所以是无法被继承的。</p>
<p>(2)毕竟通过构造函数创建实例还是SUN公司所提倡的，静态工厂方法跟其他的静态方法区别不大，这样创建的实例谁又知道这个静态方法是创建实例呢？弥补的办法就是：静态工厂方法名字使用valueOf或者getInstance.</p>
<p>3、当实现类比较多时，工厂类中的逻辑判断会比较复杂。而且当新增实现类时，需要修改工厂类的代码，违反了开-闭原则。要避免这种情况的发生，可以使用反射机制来避免这种问题。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7473.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Equals与Hashcode</title>
		<link>http://www.xieziming.com/archives/7437.html</link>
		<comments>http://www.xieziming.com/archives/7437.html#respond</comments>
		<pubDate>Thu, 04 Oct 2012 06:20:42 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7437</guid>
		<description><![CDATA[1. 首先equals()是从object类中继承过来的。 equals()方法在object类中定义如下： 
<code lang="java">
public boolean equals(Object obj) { 
   return (this == obj); 
} 
</code>
很明显是对两个对象的地址值进行的比较（即比较引用是否相同）。但是我们必需清楚，当String 、Math、Integer、Double等这些封装类在使用equals()方法时，已经覆盖了object类的equals（）方法。比如在String类中如下：
<code lang="java">
public boolean equals(Object anObject) { 
   if (this == anObject) { 
      return true; 
   } 
  if (anObject instanceof String) { 
      String anotherString = (String)anObject; 
      int n = count; 
      if (n == anotherString.count) { 
         char v1[] = value; 
         char v2[] = anotherString.value; 
         int i = offset; 
         int j = anotherString.offset; 
         while (n-- != 0) { 
            if (v1[i++] != v2[j++]) return false; 
         } 
         return true; 
      } 
  } 
  return false; 
}
</code>]]></description>
				<content:encoded><![CDATA[<p>1. 首先equals()是从object类中继承过来的。 equals()方法在object类中定义如下：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">boolean</span> equals<span style="color: #009900;">&#40;</span><span style="color: #003399;">Object</span> obj<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> 
   <span style="color: #000000; font-weight: bold;">return</span> <span style="color: #009900;">&#40;</span><span style="color: #000000; font-weight: bold;">this</span> <span style="color: #339933;">==</span> obj<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> 
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>很明显是对两个对象的地址值进行的比较（即比较引用是否相同）。但是我们必需清楚，当String 、Math、Integer、Double等这些封装类在使用equals()方法时，已经覆盖了object类的equals()方法。<br />
比如在String类中如下：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">boolean</span> equals<span style="color: #009900;">&#40;</span><span style="color: #003399;">Object</span> anObject<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> 
   <span style="color: #000000; font-weight: bold;">if</span> <span style="color: #009900;">&#40;</span><span style="color: #000000; font-weight: bold;">this</span> <span style="color: #339933;">==</span> anObject<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> 
      <span style="color: #000000; font-weight: bold;">return</span> <span style="color: #000066; font-weight: bold;">true</span><span style="color: #339933;">;</span> 
   <span style="color: #009900;">&#125;</span> 
   <span style="color: #000000; font-weight: bold;">if</span> <span style="color: #009900;">&#40;</span>anObject <span style="color: #000000; font-weight: bold;">instanceof</span> <span style="color: #003399;">String</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> 
      <span style="color: #003399;">String</span> anotherString <span style="color: #339933;">=</span> <span style="color: #009900;">&#40;</span><span style="color: #003399;">String</span><span style="color: #009900;">&#41;</span>anObject<span style="color: #339933;">;</span> 
      <span style="color: #000066; font-weight: bold;">int</span> n <span style="color: #339933;">=</span> count<span style="color: #339933;">;</span> 
      <span style="color: #000000; font-weight: bold;">if</span> <span style="color: #009900;">&#40;</span>n <span style="color: #339933;">==</span> anotherString.<span style="color: #006633;">count</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> 
         <span style="color: #000066; font-weight: bold;">char</span> v1<span style="color: #009900;">&#91;</span><span style="color: #009900;">&#93;</span> <span style="color: #339933;">=</span> value<span style="color: #339933;">;</span> 
         <span style="color: #000066; font-weight: bold;">char</span> v2<span style="color: #009900;">&#91;</span><span style="color: #009900;">&#93;</span> <span style="color: #339933;">=</span> anotherString.<span style="color: #006633;">value</span><span style="color: #339933;">;</span> 
         <span style="color: #000066; font-weight: bold;">int</span> i <span style="color: #339933;">=</span> offset<span style="color: #339933;">;</span> 
         <span style="color: #000066; font-weight: bold;">int</span> j <span style="color: #339933;">=</span> anotherString.<span style="color: #006633;">offset</span><span style="color: #339933;">;</span> 
         <span style="color: #000000; font-weight: bold;">while</span> <span style="color: #009900;">&#40;</span>n<span style="color: #339933;">--</span> <span style="color: #339933;">!=</span> <span style="color: #cc66cc;">0</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span> 
            <span style="color: #000000; font-weight: bold;">if</span> <span style="color: #009900;">&#40;</span>v1<span style="color: #009900;">&#91;</span>i<span style="color: #339933;">++</span><span style="color: #009900;">&#93;</span> <span style="color: #339933;">!=</span> v2<span style="color: #009900;">&#91;</span>j<span style="color: #339933;">++</span><span style="color: #009900;">&#93;</span><span style="color: #009900;">&#41;</span> <span style="color: #000000; font-weight: bold;">return</span> <span style="color: #000066; font-weight: bold;">false</span><span style="color: #339933;">;</span> 
         <span style="color: #009900;">&#125;</span> 
         <span style="color: #000000; font-weight: bold;">return</span> <span style="color: #000066; font-weight: bold;">true</span><span style="color: #339933;">;</span> 
      <span style="color: #009900;">&#125;</span> 
   <span style="color: #009900;">&#125;</span> 
   <span style="color: #000000; font-weight: bold;">return</span> <span style="color: #000066; font-weight: bold;">false</span><span style="color: #339933;">;</span> 
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>或者看看下面这个重写的equals(Object obj)方法：</p>

<div class="wp_code"><div class="pre"><pre class="java" style="font-family:'Times New Roman',Garamond, Times;"><span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000000; font-weight: bold;">class</span> UserInfo <span style="color: #009900;">&#123;</span>
  <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #003399;">String</span> userName<span style="color: #339933;">;</span>
  <span style="color: #000000; font-weight: bold;">private</span> <span style="color: #000066; font-weight: bold;">int</span> userAge<span style="color: #339933;">;</span> 
  <span style="color: #000000; font-weight: bold;">public</span> UserInfo<span style="color: #009900;">&#40;</span><span style="color: #003399;">String</span> userName, <span style="color: #000066; font-weight: bold;">int</span> userAge<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
    <span style="color: #000000; font-weight: bold;">super</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
    <span style="color: #000000; font-weight: bold;">this</span>.<span style="color: #006633;">userName</span> <span style="color: #339933;">=</span> userName<span style="color: #339933;">;</span>
    <span style="color: #000000; font-weight: bold;">this</span>.<span style="color: #006633;">userAge</span> <span style="color: #339933;">=</span> userAge<span style="color: #339933;">;</span>
  <span style="color: #009900;">&#125;</span>
  @Override
  <span style="color: #000000; font-weight: bold;">public</span> <span style="color: #000066; font-weight: bold;">boolean</span> equals<span style="color: #009900;">&#40;</span><span style="color: #003399;">Object</span> obj<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
    <span style="color: #000000; font-weight: bold;">if</span><span style="color: #009900;">&#40;</span>obj<span style="color: #339933;">==</span><span style="color: #000000; font-weight: bold;">this</span><span style="color: #009900;">&#41;</span>   <span style="color: #000000; font-weight: bold;">return</span> <span style="color: #000066; font-weight: bold;">true</span><span style="color: #339933;">;</span>
    UserInfo userinfo<span style="color: #339933;">=</span><span style="color: #009900;">&#40;</span>UserInfo<span style="color: #009900;">&#41;</span>obj<span style="color: #339933;">;</span>
    <span style="color: #000000; font-weight: bold;">if</span><span style="color: #009900;">&#40;</span>userName.<span style="color: #006633;">equals</span><span style="color: #009900;">&#40;</span>userinfo.<span style="color: #006633;">getUserName</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span> <span style="color: #339933;">&amp;&amp;</span> userAge<span style="color: #339933;">==</span>userinfo.<span style="color: #006633;">getUserAge</span><span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #009900;">&#41;</span>  <span style="color: #000000; font-weight: bold;">return</span> <span style="color: #000066; font-weight: bold;">true</span><span style="color: #339933;">;</span>
    <span style="color: #000000; font-weight: bold;">return</span> <span style="color: #000066; font-weight: bold;">false</span><span style="color: #339933;">;</span>
  <span style="color: #009900;">&#125;</span>
<span style="color: #009900;">&#125;</span></pre></div></div>

<p>很明显，这是进行的内容比较，而已经不再是地址的比较。依次类推Double、Integer、Math等等这些类都是重写了equals()方法的，从而进行的是内容的比较。当然了基本类型是进行值的比较，这个没有什么好说的。 </p>
<p>我们还应该注意，Java语言对equals()的要求如下，这些要求是必须遵循的：</p>
<p>• 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。<br />
• 反射性：x.equals(x)必须返回是“true”。<br />
• 类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。<br />
• 还有一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。<br />
• 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。 </p>
<p>以上这五点是重写equals()方法时，必须遵守的准则，如果违反会出现意想不到的结果，请大家一定要遵守。 </p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7437.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java IO类</title>
		<link>http://www.xieziming.com/archives/7000.html</link>
		<comments>http://www.xieziming.com/archives/7000.html#respond</comments>
		<pubDate>Wed, 03 Oct 2012 13:20:35 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7000</guid>
		<description><![CDATA[(1)FileInputStream和FileOutputStream
节点流，用于从文件中读取或往文件中写入字节流。如果在构造FileOutputStream时，文件已经存在，则覆盖这个文件。

(2)BufferedInputStream和BufferedOutputStream
过滤流，需要使用已经存在的节点流来构造，提供带缓冲的读写，提高了读写的效率。

(3)DataInputStream和DataOutputStream
过滤流，需要使用已经存在的节点流来构造，提供了读写Java中的基本数据类型的功能。

(4)PipedInputStream和PipedOutputStream
管道流，用于线程间的通信。一个线程的PipedInputStream对象从另一个线程的PipedOutputStream对象读取输入。要使管道流有用，必须同时构造管道输入流和管道输出流。]]></description>
				<content:encoded><![CDATA[<p><strong>Java IO类分类：</strong></p>
<p>按流向分:　　<br />
输入流: 程序可以从中读取数据的流。　　<br />
输出流: 程序能向其中写入数据的流。<br />
　　<br />
按数据传输单位分:　　<br />
字节流: 以字节为单位传输数据的流<br />
字符流: 以字符为单位传输数据的流<br />
　　<br />
按功能分:　　<br />
节点流：从特定的地方读写的流类，例如：磁盘或一块内存区域。<br />
过滤流：使用节点流作为输入或输出。过滤流是使用一个已经存在的输入流或输出流连接创建的。 </p>
<p>InputStream和Reader是所有输入流的基类，OutputStream和Writer是所有输出流的基类。他们都是抽象类，本身并不能创建实例来执行输入，但他们有输入/输出流的模版，所以它们的方法是所有的输入/输出流可以用的方法。</p>
<p>从Stream到Reader,Writer的转换类：InputStreamReader, OutputStreamWriter</p>
<p>BufferedReader(FileReader(String)), BufferedReader(InputStreamReader(FileInputStream(String)))</p>
<p><strong>简单来讲，要有BufferedReader，先要有Reader，这个Reader可以直接来自FileReader,也可以从InputStream转化而来，这个时候就需要InputStreamReader做桥梁。</strong></p>
<p>InputStreamReader和FileReader处于同一层，读写方法差不多。</p>
<p><strong>基本的流类:</strong></p>
<p>(1)FileInputStream和FileOutputStream<br />
节点流，用于从文件中读取或往文件中写入字节流。如果在构造FileOutputStream时，文件已经存在，则覆盖这个文件。</p>
<p>(2)BufferedInputStream和BufferedOutputStream<br />
过滤流，需要使用已经存在的节点流来构造，提供带缓冲的读写，提高了读写的效率。</p>
<p>(3)DataInputStream和DataOutputStream<br />
过滤流，需要使用已经存在的节点流来构造，提供了读写Java中的基本数据类型的功能。</p>
<p>(4)PipedInputStream和PipedOutputStream<br />
管道流，用于线程间的通信。一个线程的PipedInputStream对象从另一个线程的PipedOutputStream对象读取输入。要使管道流有用，必须同时构造管道输入流和管道输出流。</p>
<p>在InputStream里常用的方法：</p>
<p>int read(): 从输入流中读取单个字节<br />
int read(byte[] b): 从输入流中读取最多b.length个字节，将读取的字节存在数组b中，返回实际读取的字节数<br />
int read(byte[] b, int off, int len): 从输入流中读取最多len个字节数据，并将其存储在数字b中，放入b数组中时，并不是从数组起点开始，而是从off位置开始，返回实际读取字节数。</p>
<p>在Reader里经常使用的方法：</p>
<p>int read(): 从输入流中读取单个字符<br />
int read(char[] c): 从输入流读取最多c.length个字符数据，并将其存储在字符数组c中，返回实际读取的字符<br />
int read(char[] c, int off, int len): 从输入流中读取最多len个字符的数据，将读取的数据放到字符数组c中保存，从数组的off开始读取。</p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7000.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java多态总结</title>
		<link>http://www.xieziming.com/archives/7402.html</link>
		<comments>http://www.xieziming.com/archives/7402.html#respond</comments>
		<pubDate>Mon, 24 Sep 2012 15:32:11 +0000</pubDate>
		<dc:creator><![CDATA[Suny Tse]]></dc:creator>
				<category><![CDATA[程序]]></category>
		<category><![CDATA[java]]></category>
		<category><![CDATA[Summary]]></category>

		<guid isPermaLink="false">http://www.xieziming.com/?p=7402</guid>
		<description><![CDATA[Java的多态性总结： 

(1) 首先, 要明确Child对Parent发生了方法的overload还是overwrite，根据参数类型及个数。 

(2) 如果是overload，则Child继承了Parent的方法，相当于Child多加了父类的方法。 

(3) 如果是overwrite， 则Child类不会有父类的该方法，而是把该方法重写了，所以该方法存在于父类中，子类只是重写了。要想调用父类的该方法，只能通过super关键字调用。java 的这种机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 

(4) 接下来，观察方法执行时的参数类型； 

(5) 然后看调用对象的声明类型和实例类型； 

(6) 方法的调度采用最精确参数匹配。]]></description>
				<content:encoded><![CDATA[<p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>比方一下:</p>
<p>你和你朋友都是烟鬼,</p>
<p>某日,你没有带烟, 而你朋友有n种烟,</p>
<p>你说: 来根烟,</p>
<p>朋友给你一根;</p>
<p>你通过烟的过滤嘴, 品出为白沙烟</p>
<p>你再要一根,</p>
<p>品出这次是芙蓉王,</p>
<p>再要一根,</p>
<p>品出这次是熊猫</p>
<p>&#8230;</p>
<p>上面描述的就是多态!</p>
<p>烟 a = 白沙<br />
烟 b = 芙蓉王<br />
烟 c = 熊猫</p>
<p>但发现没有, 仅仅通过&#8221;烟&#8221;基类, 引用到不同的具体类对象, 就能让你调用到不同的对象, 这就是多态. 而烟到你嘴里[此时你还没有发现是那种烟], 你仅仅凭借&#8221;吸&#8221;的动作,就识别出来,到底是哪种烟对象</p>
<p>这就是多态的悬机.</p>
<p>多态须具备:</p>
<p>1. 基类和各个子类</p>
<p>2. 基类引用, 指向实例化的子类对象.</p>
<p>再举一个鸡的例子,</p>
<p>鸡是所有其它鸡的基类, 定义了一个方法shape(), 此方法能指明鸡的形态. 所有的子类[火鸡,山鸡,田鸡等],都有这个shape方法, 表明自己的形态,</p>
<p>如果用下面的方法定义我需要具体的鸡,</p>
<p>[基类 引用 = 实现类的对象]</p>
<p>for example:</p>
<p>鸡 a = new 火鸡();</p>
<p>鸡 a = new 田鸡();</p>
<p>鸡 a = new 山鸡();</p>
<p>鸡 a = new 母鸡();</p>
<p>当我使用的时候, 我采用 a 这个引用,</p>
<p>a.shape(), 就会得到鸡的形态.</p>
<p>如果我定义的是</p>
<p>鸡 a = new 火鸡();</p>
<p>那么a.shape得到的是火鸡的形态, 而不需要用具体的</p>
<p>火鸡 a = new 火鸡(); 再通过a.shape得到火鸡的形态</p>
]]></content:encoded>
			<wfw:commentRss>http://www.xieziming.com/archives/7402.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
